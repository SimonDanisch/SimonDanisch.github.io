{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome the Documentation of GLVisualize\n\n\nGLVisualize is an interactive 3D visualization library written in Julia and modern OpenGL. \nIts focus is on scientific visualizations but is not restricted to it.\nThere are lots of 2D and 3D visualization types like particles, surfaces, meshes, sprites, lines and text.\nIt uses \nReactive\n to offer an easy way of animating your data.\nIt also offers very basic GUI elements like slider and buttons.\n\n\nPlease check out the examples to see what GLVisualize is capable of.\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.\n\n\n\nYour browser does not support the video tag.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-the-documentation-of-glvisualize", 
            "text": "GLVisualize is an interactive 3D visualization library written in Julia and modern OpenGL. \nIts focus is on scientific visualizations but is not restricted to it.\nThere are lots of 2D and 3D visualization types like particles, surfaces, meshes, sprites, lines and text.\nIt uses  Reactive  to offer an easy way of animating your data.\nIt also offers very basic GUI elements like slider and buttons.  Please check out the examples to see what GLVisualize is capable of.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.  Your browser does not support the video tag.", 
            "title": "Welcome the Documentation of GLVisualize"
        }, 
        {
            "location": "/api/", 
            "text": "## This API documentation was generated automatically and is a work in progress.\n\n\n\nsprites\n\n\nargs: \n(::Any, ::Any, ::Any)\n\n\nMain assemble functions for sprite particles. Sprites are anything like distance fields, images and simple geometries\n\n\n\n\nprojection_switch\n\n\nargs: \n(::Any, ::Any, ::Any)\n\n\ncreates a button that can switch between orthographic and perspective projection\n\n\n\n\nclicked\n\n\nargs: \n(::RenderObject, ::MouseButton, ::Screen)\n\n\nReturns two signals, one boolean signal if clicked over \nrobj\n and another one that consists of the object clicked on and another argument indicating that it's the first click\n\n\n\n\nto_indices\n\n\nargs: \n(::Union{Signal Int64})\n\n\nConverts index arrays to the OpenGL equivalent.\n\n\n\n\nargs: \n(::Array)\n\n\nIf already GLuint, we assume its 0 based (bad heuristic, should better be solved with some Index type)\n\n\n\n\nargs: \n(::Array)\n\n\nFor integers, we transform it to 0 based indices\n\n\n\n\ncubecamera\n\n\nargs: \n(::Any)\n\n\nCreates a camera which is steered by a cube for \nwindow\n.\n\n\n\n\nGrid\n\n\nargs: \n(::AbstractArray, ::Tuple)\n\n\nThis constructor constructs a grid from ranges given as a tuple. Due to the approach, the tuple \nranges\n can consist of NTuple(2, T) and all kind of range types. The constructor will make sure that all ranges match the size of the dimension of the array \na\n.\n\n\n\n\nis_hovering\n\n\nargs: \n(::RenderObject, ::Screen)\n\n\nReturns a boolean signal indicating if the mouse hovers over \nrobj\n\n\n\n\nplay\n\n\nargs: \n(::Array, ::Integer, ::Integer)\n\n\nWith play, you can slice a 3D array along \ntimedim\n at time \nt\n. This can be used to treat a 3D array like a video and create an image stream from it.\n\n\n\n\nargs: \n(::Image)\n\n\nTurns an Image into a video stream\n\n\n\n\nargs: \n(::Array, ::Any, ::Any)\n\n\nPlays a video stream from VideoIO.jl. You need to supply the image \nbuffer\n, which will be reused for better performance.\n\n\n\n\nvisualize\n\n\nargs: \n(::Tuple, ::Tuple)\n\n\nCreates a default visualization for any value. The defaults can be customized via the key word arguments and the style parameter. The style can change the the look completely (e.g points displayed as lines, or particles), while the key word arguments just alter the parameters of one visualization. Always returns a context, which can be displayed on a window via view(::Context, [display]).\n\n\n\n\nmeshparticle\n\n\nargs: \n(::Any, ::Any, ::Any)\n\n\nThis is the main function to assemble particles with a GLNormalMesh as a primitive\n\n\n\n\ndragged_on\n\n\nargs: \n(::RenderObject, ::MouseButton, ::Screen)\n\n\nReturns a signal with the difference from dragstart and current mouse position, and the index from the current ROBJ id.\n\n\n\n\n_default\n\n\nargs: \n(::Union{Signal Array GPUArray}, ::Style, ::Dict)\n\n\nVectors of n-dimensional points get ndimensional rectangles as default primitives. (Particles)\n\n\n\n\nargs: \n(::Tuple, ::Style, ::Dict)\n\n\nSprites primitives with a vector of floats are treated as something barplot like\n\n\n\n\nargs: \n(::Tuple, ::Style, ::Dict)\n\n\narrays of floats with any geometry primitive, will be spaced out on a grid defined by \nranges\n and will use the floating points as the height for the primitives (\nscale_z\n)\n\n\n\n\nargs: \n(::Union{Signal S}, ::Style, ::Dict)\n\n\nTransforms text into a particle system of sprites, by inferring the texture coordinates in the texture atlas, widths and positions of the characters.\n\n\n\n\nargs: \n(::Union{Array Signal GPUArray}, ::Style, ::Dict)\n\n\n3D matrices of vectors are 3D vector field with a pyramid (arrow) like default primitive.\n\n\n\n\nargs: \n(::Tuple, ::Style, ::Dict)\n\n\nVectors with \nVec\n as element type are treated as vectors of rotations. The position is assumed to be implicitely on the grid the vector defines (1D,2D,3D grid)\n\n\n\n\nargs: \n(::Shader, ::Style, ::Dict)\n\n\nTakes a shader as a parametric function. The shader should contain a function stubb like this:\n\n\nuniform float arg1; // you can add arbitrary uniforms and supply them via the keyword args\nfloat function(float x) {\n return arg1*sin(1/tan(x));\n}\n\n\n\n\n\n\nargs: \n(::Union{Array GPUArray Signal}, ::Style, ::Dict)\n\n\nFloat matrix with the style distancefield will be interpreted as a distancefield. A distancefield is describing a shape, with positive values denoting the inside of the shape, negative values the outside and 0 the border\n\n\n\n\nargs: \n(::Image, ::Style, ::Dict)\n\n\nTakes a 3D image and decides if it is a volume or an animated Image.\n\n\n\n\nargs: \n(::Union{Signal Array GPUArray}, ::Style, ::Dict)\n\n\nA matrix of Intensities will result in a contourf kind of plot\n\n\n\n\nargs: \n(::Union{Array GPUArray Signal}, ::Style, ::Dict)\n\n\nMatrices of floats are represented as 3D barplots with cubes as primitive\n\n\n\n\nargs: \n(::Union{G Signal}, ::Style, ::Dict)\n\n\nWe plot simple Geometric primitives as particles with length one. At some point, this should all be appended to the same particle system to increase performance.\n\n\n\n\nargs: \n(::Tuple, ::Style, ::Dict)\n\n\narrays of floats with the sprite primitive type (2D geometry + picture like), will be spaced out on a grid defined by \nranges\n and will use the floating points as the z position for the primitives.\n\n\n\n\nargs: \n(::Union{GPUArray Array Signal}, ::Style, ::Dict)\n\n\n2D matrices of vectors are 2D vector field with a an unicode arrow as the default primitive.\n\n\n\n\nargs: \n(::Union{GPUArray Signal Array}, ::Style, ::Dict)\n\n\nVectors of floats are treated as barplots, so they get a HyperRectangle as default primitive.\n\n\n\n\nargs: \n(::Union{Array GPUArray Signal}, ::Style, ::Dict)\n\n\nA matrix of colors is interpreted as an image\n\n\n\n\nargs: \n(::Union{Array Signal GPUArray}, ::Style, ::Dict)\n\n\nThis is the most primitive particle system, which uses simple points as primitives. This is supposed to be very fast!", 
            "title": "Api"
        }, 
        {
            "location": "/api/#sprites", 
            "text": "args:  (::Any, ::Any, ::Any)  Main assemble functions for sprite particles. Sprites are anything like distance fields, images and simple geometries", 
            "title": "sprites"
        }, 
        {
            "location": "/api/#projection_switch", 
            "text": "args:  (::Any, ::Any, ::Any)  creates a button that can switch between orthographic and perspective projection", 
            "title": "projection_switch"
        }, 
        {
            "location": "/api/#clicked", 
            "text": "args:  (::RenderObject, ::MouseButton, ::Screen)  Returns two signals, one boolean signal if clicked over  robj  and another one that consists of the object clicked on and another argument indicating that it's the first click", 
            "title": "clicked"
        }, 
        {
            "location": "/api/#to_indices", 
            "text": "args:  (::Union{Signal Int64})  Converts index arrays to the OpenGL equivalent.   args:  (::Array)  If already GLuint, we assume its 0 based (bad heuristic, should better be solved with some Index type)   args:  (::Array)  For integers, we transform it to 0 based indices", 
            "title": "to_indices"
        }, 
        {
            "location": "/api/#cubecamera", 
            "text": "args:  (::Any)  Creates a camera which is steered by a cube for  window .", 
            "title": "cubecamera"
        }, 
        {
            "location": "/api/#grid", 
            "text": "args:  (::AbstractArray, ::Tuple)  This constructor constructs a grid from ranges given as a tuple. Due to the approach, the tuple  ranges  can consist of NTuple(2, T) and all kind of range types. The constructor will make sure that all ranges match the size of the dimension of the array  a .", 
            "title": "Grid"
        }, 
        {
            "location": "/api/#is_hovering", 
            "text": "args:  (::RenderObject, ::Screen)  Returns a boolean signal indicating if the mouse hovers over  robj", 
            "title": "is_hovering"
        }, 
        {
            "location": "/api/#play", 
            "text": "args:  (::Array, ::Integer, ::Integer)  With play, you can slice a 3D array along  timedim  at time  t . This can be used to treat a 3D array like a video and create an image stream from it.   args:  (::Image)  Turns an Image into a video stream   args:  (::Array, ::Any, ::Any)  Plays a video stream from VideoIO.jl. You need to supply the image  buffer , which will be reused for better performance.", 
            "title": "play"
        }, 
        {
            "location": "/api/#visualize", 
            "text": "args:  (::Tuple, ::Tuple)  Creates a default visualization for any value. The defaults can be customized via the key word arguments and the style parameter. The style can change the the look completely (e.g points displayed as lines, or particles), while the key word arguments just alter the parameters of one visualization. Always returns a context, which can be displayed on a window via view(::Context, [display]).", 
            "title": "visualize"
        }, 
        {
            "location": "/api/#meshparticle", 
            "text": "args:  (::Any, ::Any, ::Any)  This is the main function to assemble particles with a GLNormalMesh as a primitive", 
            "title": "meshparticle"
        }, 
        {
            "location": "/api/#dragged_on", 
            "text": "args:  (::RenderObject, ::MouseButton, ::Screen)  Returns a signal with the difference from dragstart and current mouse position, and the index from the current ROBJ id.", 
            "title": "dragged_on"
        }, 
        {
            "location": "/api/#_default", 
            "text": "args:  (::Union{Signal Array GPUArray}, ::Style, ::Dict)  Vectors of n-dimensional points get ndimensional rectangles as default primitives. (Particles)   args:  (::Tuple, ::Style, ::Dict)  Sprites primitives with a vector of floats are treated as something barplot like   args:  (::Tuple, ::Style, ::Dict)  arrays of floats with any geometry primitive, will be spaced out on a grid defined by  ranges  and will use the floating points as the height for the primitives ( scale_z )   args:  (::Union{Signal S}, ::Style, ::Dict)  Transforms text into a particle system of sprites, by inferring the texture coordinates in the texture atlas, widths and positions of the characters.   args:  (::Union{Array Signal GPUArray}, ::Style, ::Dict)  3D matrices of vectors are 3D vector field with a pyramid (arrow) like default primitive.   args:  (::Tuple, ::Style, ::Dict)  Vectors with  Vec  as element type are treated as vectors of rotations. The position is assumed to be implicitely on the grid the vector defines (1D,2D,3D grid)   args:  (::Shader, ::Style, ::Dict)  Takes a shader as a parametric function. The shader should contain a function stubb like this:  uniform float arg1; // you can add arbitrary uniforms and supply them via the keyword args\nfloat function(float x) {\n return arg1*sin(1/tan(x));\n}   args:  (::Union{Array GPUArray Signal}, ::Style, ::Dict)  Float matrix with the style distancefield will be interpreted as a distancefield. A distancefield is describing a shape, with positive values denoting the inside of the shape, negative values the outside and 0 the border   args:  (::Image, ::Style, ::Dict)  Takes a 3D image and decides if it is a volume or an animated Image.   args:  (::Union{Signal Array GPUArray}, ::Style, ::Dict)  A matrix of Intensities will result in a contourf kind of plot   args:  (::Union{Array GPUArray Signal}, ::Style, ::Dict)  Matrices of floats are represented as 3D barplots with cubes as primitive   args:  (::Union{G Signal}, ::Style, ::Dict)  We plot simple Geometric primitives as particles with length one. At some point, this should all be appended to the same particle system to increase performance.   args:  (::Tuple, ::Style, ::Dict)  arrays of floats with the sprite primitive type (2D geometry + picture like), will be spaced out on a grid defined by  ranges  and will use the floating points as the z position for the primitives.   args:  (::Union{GPUArray Array Signal}, ::Style, ::Dict)  2D matrices of vectors are 2D vector field with a an unicode arrow as the default primitive.   args:  (::Union{GPUArray Signal Array}, ::Style, ::Dict)  Vectors of floats are treated as barplots, so they get a HyperRectangle as default primitive.   args:  (::Union{Array GPUArray Signal}, ::Style, ::Dict)  A matrix of colors is interpreted as an image   args:  (::Union{Array Signal GPUArray}, ::Style, ::Dict)  This is the most primitive particle system, which uses simple points as primitives. This is supposed to be very fast!", 
            "title": "_default"
        }, 
        {
            "location": "/known_issues/", 
            "text": "Known Issues\n\n\nPlease refer to the \nGithub issues\n\n\n\n\n\n\nIt's known that the camera is a bit odd, fixing is high up on the priority list.\n\n\n\n\n\n\nBoundingboxes are not always correct\n\n\n\n\nOn Mac OS, you need to make sure that Homebrew.jl works correctly, which was not the case on some tested machines (needed to checkout master and then rebuild)\n\n\nGLFW needs cmake and xorg-dev libglu1-mesa-dev on linux (can be installed via sudo apt-get install xorg-dev libglu1-mesa-dev).\n\n\nVideoIO and FreeType seem to be also problematic on some platforms. There isn't a fix for all situations. If these package fail, try Pk.update();Pkg.build(\"FailedPackage\"). If this still fails, report an issue on Github!", 
            "title": "Known issues"
        }, 
        {
            "location": "/known_issues/#known-issues", 
            "text": "Please refer to the  Github issues    It's known that the camera is a bit odd, fixing is high up on the priority list.    Boundingboxes are not always correct   On Mac OS, you need to make sure that Homebrew.jl works correctly, which was not the case on some tested machines (needed to checkout master and then rebuild)  GLFW needs cmake and xorg-dev libglu1-mesa-dev on linux (can be installed via sudo apt-get install xorg-dev libglu1-mesa-dev).  VideoIO and FreeType seem to be also problematic on some platforms. There isn't a fix for all situations. If these package fail, try Pk.update();Pkg.build(\"FailedPackage\"). If this still fails, report an issue on Github!", 
            "title": "Known Issues"
        }, 
        {
            "location": "/performance/", 
            "text": "Performance tips for GLVisualize\n\n\nGLVisualize doesn't optimize drawing many RenderObjects objects well yet.\nBetter OpenGL draw call optimization would be needed for that.\nSo if you need to draw many objects, make sure that you use the particle system or merge meshes whenever possible.\n\n\nFor animations, make sure to pass a static boundingbox via the keyword arguments.\n\n\nE.g:\n\n\nvisualize(x, boundingbox=nothing) # Or AABB{Float32}(Vec3f0(0),Vec3f0(0))\n\n\n\n\nOtherwise the boundinbox will be calculated every time the signal updates which can be very expensive.\n\n\nIf you want to find out a bit more about the genral performance of GLVisualize, you can\nread this \nblog post\n.\nIt's a bit outdated but should still be accurate.", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#performance-tips-for-glvisualize", 
            "text": "GLVisualize doesn't optimize drawing many RenderObjects objects well yet.\nBetter OpenGL draw call optimization would be needed for that.\nSo if you need to draw many objects, make sure that you use the particle system or merge meshes whenever possible.  For animations, make sure to pass a static boundingbox via the keyword arguments.  E.g:  visualize(x, boundingbox=nothing) # Or AABB{Float32}(Vec3f0(0),Vec3f0(0))  Otherwise the boundinbox will be calculated every time the signal updates which can be very expensive.  If you want to find out a bit more about the genral performance of GLVisualize, you can\nread this  blog post .\nIt's a bit outdated but should still be accurate.", 
            "title": "Performance tips for GLVisualize"
        }, 
        {
            "location": "/examples/camera/", 
            "text": "Billiard\n\n\n Your browser does not support the video tag. \n\n\n\n#=\nFor this example you need to checkout this package:\nPkg.clone(\nhttps://github.com/dpsanders/BilliardModels.jl\n)\nPkg.checkout(\nBilliardModels\n, \ntime_step\n)\n=#\nusing GLAbstraction, MeshIO, Colors\nusing GLVisualize, GeometryTypes, Reactive, ColorTypes\nwindow = glscreen()\nconst interactive_example = true\n\nusing BilliardModels\n\n# create the billiard table\nconst table = Sinai_billiard(0.1)\nconst max_particles = 8_000\n\n# function that steps through the simulation\nfunction BilliardModels.step!(particles, table, _)\n    for particle in particles\n        BilliardModels.step!(particle, table, 0.01)\n    end\n    particles\nend\n\n# convert a particle to a point\nfunction to_points(data, particles)\n    @inbounds for (i,p) in enumerate(particles)\n        data[i] = to_points(p)\n    end\n    data\nend\nto_points(p::BilliardModels.Particle) = Point3f0(p.x.x*2pi, p.x.y*2pi, atan2(p.v.x, p.v.y))\n\n# color lookup table\nconst colorramp = map(RGBA{Float32}, colormap(\nRdBu\n, 100))\nfunction to_color(p::BilliardModels.Particle)\n    l = (atan2(p.v.x, p.v.y) + pi) / 2pi\n    colorramp[round(Int, clamp(l, 0, 1) * (length(colorramp)-1))+1]\nend\nfunction to_color(data, particles)\n    @inbounds for (i,p) in enumerate(particles)\n        data[i] = to_color(p)\n    end\n    data\nend\n\ncubecamera(window)\n\nx0              = Vector2D(0.3, 0.1)\nparticles       = [BilliardModels.Particle(x0, Vector2D(1.0, 0.001*i)) for i=1:max_particles]\ncolors          = RGBA{Float32}[RGBA{Float32}(1., 0.1, clamp(0.001*i, 0.0, 1.0), 1.0) for i=1:max_particles]\nparticle_stream = const_lift(BilliardModels.step!, particles, table, bounce(1:10))\nv0              = map(to_points, particles)\nvc0             = map(to_color, particles)\ncolors          = const_lift(to_color, vc0, particle_stream)\npointstream     = const_lift(to_points, v0, particle_stream)\nprimitive       = Circle(Point2f0(0), 0.05f0)\n\n# we know that the particles will only be in this range\nboundingbox     = AABB{Float32}(Vec3f0(-pi), Vec3f0(2pi))\nparticles = visualize(\n    (primitive, pointstream),\n    color=colors, # set color array. This is per particle\n    billboard=true, # set billboard to true, making the particles always face the camera\n    boundingbox=Signal(boundingbox) # set boundingbox, to avoid bb re-calculation when particles update( is expensive)\n)\n\n# visualize the boundingbox\nboundingbox = visualize(boundingbox, :lines)\n# view them (add them to the windows render list)\nview(particles, window, camera=:perspective)\nview(boundingbox, window, camera=:perspective)\n\n\nrenderloop(window)\n\n\n\n\n\nCamera\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction, FileIO, GeometryTypes, Reactive, GLWindow, Colors\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nconst interactive_example = true\n\n\n\nfunctions to halve some rectangle\n\n\nxhalf(r)  = SimpleRectangle(r.x, r.y, r.w\u00f72, r.h)\nxhalf2(r) = SimpleRectangle(r.w\u00f72, r.y, r.w\u00f72, r.h)\n\n\n\nMakes a spiral\n\n\nfunction spiral(i, start_radius, offset)\n    Point3f0(sin(i), cos(i), i/10f0) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\ncurve_data(i, N) = Point3f0[spiral(i+x/20f0, 1, (i/20)+1) for x=1:N]\n# create a spiraling camera path\nconst camera_path  = curve_data(1f0, 360)\n\n# create first screen for the camera\ncamera_screen = Screen(\n    window, name=:camera_screen,\n    area=const_lift(xhalf2, window.area)\n)\n# create second screen to view the scene\nscene_screen = Screen(\n    window, name=:scene_screen,\n    area=const_lift(xhalf, window.area)\n)\n\n# create an camera eyeposition signal, which follows the path\neyeposition = map(timesignal) do t\n    len = length(camera_path)\n    index = round(Int, (t*(len-1))+1) # mod1, just to be on the save side\n    Vec3f0(camera_path[index])\nend\n\n# create the camera lookat and up vector\nlookatposition = Signal(Vec3f0(0))\nupvector = Signal(Vec3f0(0,0,1))\n\n# create a camera from these\ncam = PerspectiveCamera(camera_screen.area, eyeposition, lookatposition, upvector)\n\n\n\nSimple visualization of a camera (this could be moved to GLVisualize)\n\n\nfunction GLVisualize.visualize(cam::PerspectiveCamera, style, keyword_args)\n    lookvec, posvec, upvec = map(f-\ncam.(f), (:lookat, :eyeposition, :up))\n    positions = map((a,b) -\n Point3f0[a,b], lookvec, posvec)\n    lines = map(lookvec, posvec, upvec) do l,p,u\n        dir = p-l\n        right = normalize(cross(dir,u))\n        Point3f0[\n            l,p,\n            p, p+u,\n            p, p+right\n        ]\n    end\n    colors = RGBA{Float32}[\n        RGBA{Float32}(1,0,0,1),\n        RGBA{Float32}(1,0,0,1),\n\n        RGBA{Float32}(0,1,0,1),\n        RGBA{Float32}(0,1,0,1),\n\n        RGBA{Float32}(0,0,1,1),\n        RGBA{Float32}(0,0,1,1),\n    ]\n    poses = visualize((Sphere(Point3f0(0), 0.05f0), positions))\n    lines = visualize(lines, :linesegment, color=colors)\n    Context(poses, lines)\nend\n\n# add the camera to the camera screen as the perspective camera\ncamera_screen.cameras[:perspective] = cam\n\n# something to look at\ncat = visualize(GLNormalMesh(loadasset(\ncat.obj\n)))\n\n# visualize the camera path\ncamera_points = visualize(\n    (Circle(Point2f0(0), 0.03f0), camera_path),\n    color=RGBA{Float32}((Vec3f0(0,206,209)/256)..., 1f0), billboard=true\n)\ncamera_path_line = visualize(camera_path, :lines)\n\n\n\nCopy function for a context. We only need to copy the uniform dict\n\n\nfunction copy(c::GLAbstraction.Context)\n    a = c.children[]\n    uniforms = Dict{Symbol, Any}([k=\nv for (k,v) in a.uniforms])\n    robj = RenderObject(\n        a.main,\n        uniforms,\n        a.vertexarray,\n        a.prerenderfunctions,\n        a.postrenderfunctions,\n        a.id,\n        a.boundingbox,\n    )\n    Context(robj)\nend\n\n# view everything on the appropriate screen.\n# we need to copy the cat, because view inserts the camera into the\n# actual render object. this is sub optimal and will get changed!\n# Note, that this is a shallow copy, so the actual data won't be copied,\n# just the data structure that holds the camera\nview(copy(cat), camera_screen, camera=:perspective)\n\nview(copy(cat), scene_screen, camera=:perspective)\n\nview(visualize(cam), scene_screen, camera=:perspective)\n\nview(camera_points, scene_screen, camera=:perspective)\nview(camera_path_line, scene_screen, camera=:perspective)\n\n\n\nrenderloop(window)\n\n\n\n\n\nCamera2\n\n\nusing GLVisualize, GLAbstraction, FileIO, GeometryTypes, Reactive\n\nw = glscreen()\n\nrobj         = visualize(rand(Float32, 32,32), :surface)\nbb           = boundingbox(robj).value\nbb_width     = widths(bb)\nlower_corner = minimum(bb)\nmiddle       = lower_corner + (bb_width/2f0)\nlookatvec    = Signal(Vec3f0(0))\neyeposition  = Signal(Vec3f0(2))\n\nideal_eyepos = middle + (norm(bb_width)*Vec3f0(2,0,2))\n\n\ntheta, translation = GLAbstraction.default_camera_control(\n    w.inputs, Signal(0.1f0), Signal(0.01f0)\n)\nupvector     = Signal(Vec3f0(0,0,1))\n\ncam = PerspectiveCamera(\n    theta,\n    translation,\n    lookatvec,\n    eyeposition,\n    upvector,\n    w.inputs[:window_area],\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0) # Max distance (clip distance)\n)\n\nw.cameras[:my_cam] = cam\n\nview(robj, camera=:my_cam)\n\n@async renderloop(w)", 
            "title": "Camera"
        }, 
        {
            "location": "/examples/camera/#billiard", 
            "text": "Your browser does not support the video tag.   #=\nFor this example you need to checkout this package:\nPkg.clone( https://github.com/dpsanders/BilliardModels.jl )\nPkg.checkout( BilliardModels ,  time_step )\n=#\nusing GLAbstraction, MeshIO, Colors\nusing GLVisualize, GeometryTypes, Reactive, ColorTypes\nwindow = glscreen()\nconst interactive_example = true\n\nusing BilliardModels\n\n# create the billiard table\nconst table = Sinai_billiard(0.1)\nconst max_particles = 8_000\n\n# function that steps through the simulation\nfunction BilliardModels.step!(particles, table, _)\n    for particle in particles\n        BilliardModels.step!(particle, table, 0.01)\n    end\n    particles\nend\n\n# convert a particle to a point\nfunction to_points(data, particles)\n    @inbounds for (i,p) in enumerate(particles)\n        data[i] = to_points(p)\n    end\n    data\nend\nto_points(p::BilliardModels.Particle) = Point3f0(p.x.x*2pi, p.x.y*2pi, atan2(p.v.x, p.v.y))\n\n# color lookup table\nconst colorramp = map(RGBA{Float32}, colormap( RdBu , 100))\nfunction to_color(p::BilliardModels.Particle)\n    l = (atan2(p.v.x, p.v.y) + pi) / 2pi\n    colorramp[round(Int, clamp(l, 0, 1) * (length(colorramp)-1))+1]\nend\nfunction to_color(data, particles)\n    @inbounds for (i,p) in enumerate(particles)\n        data[i] = to_color(p)\n    end\n    data\nend\n\ncubecamera(window)\n\nx0              = Vector2D(0.3, 0.1)\nparticles       = [BilliardModels.Particle(x0, Vector2D(1.0, 0.001*i)) for i=1:max_particles]\ncolors          = RGBA{Float32}[RGBA{Float32}(1., 0.1, clamp(0.001*i, 0.0, 1.0), 1.0) for i=1:max_particles]\nparticle_stream = const_lift(BilliardModels.step!, particles, table, bounce(1:10))\nv0              = map(to_points, particles)\nvc0             = map(to_color, particles)\ncolors          = const_lift(to_color, vc0, particle_stream)\npointstream     = const_lift(to_points, v0, particle_stream)\nprimitive       = Circle(Point2f0(0), 0.05f0)\n\n# we know that the particles will only be in this range\nboundingbox     = AABB{Float32}(Vec3f0(-pi), Vec3f0(2pi))\nparticles = visualize(\n    (primitive, pointstream),\n    color=colors, # set color array. This is per particle\n    billboard=true, # set billboard to true, making the particles always face the camera\n    boundingbox=Signal(boundingbox) # set boundingbox, to avoid bb re-calculation when particles update( is expensive)\n)\n\n# visualize the boundingbox\nboundingbox = visualize(boundingbox, :lines)\n# view them (add them to the windows render list)\nview(particles, window, camera=:perspective)\nview(boundingbox, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Billiard"
        }, 
        {
            "location": "/examples/camera/#camera", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction, FileIO, GeometryTypes, Reactive, GLWindow, Colors\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nconst interactive_example = true \nfunctions to halve some rectangle \nxhalf(r)  = SimpleRectangle(r.x, r.y, r.w\u00f72, r.h)\nxhalf2(r) = SimpleRectangle(r.w\u00f72, r.y, r.w\u00f72, r.h) \nMakes a spiral \nfunction spiral(i, start_radius, offset)\n    Point3f0(sin(i), cos(i), i/10f0) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\ncurve_data(i, N) = Point3f0[spiral(i+x/20f0, 1, (i/20)+1) for x=1:N]\n# create a spiraling camera path\nconst camera_path  = curve_data(1f0, 360)\n\n# create first screen for the camera\ncamera_screen = Screen(\n    window, name=:camera_screen,\n    area=const_lift(xhalf2, window.area)\n)\n# create second screen to view the scene\nscene_screen = Screen(\n    window, name=:scene_screen,\n    area=const_lift(xhalf, window.area)\n)\n\n# create an camera eyeposition signal, which follows the path\neyeposition = map(timesignal) do t\n    len = length(camera_path)\n    index = round(Int, (t*(len-1))+1) # mod1, just to be on the save side\n    Vec3f0(camera_path[index])\nend\n\n# create the camera lookat and up vector\nlookatposition = Signal(Vec3f0(0))\nupvector = Signal(Vec3f0(0,0,1))\n\n# create a camera from these\ncam = PerspectiveCamera(camera_screen.area, eyeposition, lookatposition, upvector) \nSimple visualization of a camera (this could be moved to GLVisualize) \nfunction GLVisualize.visualize(cam::PerspectiveCamera, style, keyword_args)\n    lookvec, posvec, upvec = map(f- cam.(f), (:lookat, :eyeposition, :up))\n    positions = map((a,b) -  Point3f0[a,b], lookvec, posvec)\n    lines = map(lookvec, posvec, upvec) do l,p,u\n        dir = p-l\n        right = normalize(cross(dir,u))\n        Point3f0[\n            l,p,\n            p, p+u,\n            p, p+right\n        ]\n    end\n    colors = RGBA{Float32}[\n        RGBA{Float32}(1,0,0,1),\n        RGBA{Float32}(1,0,0,1),\n\n        RGBA{Float32}(0,1,0,1),\n        RGBA{Float32}(0,1,0,1),\n\n        RGBA{Float32}(0,0,1,1),\n        RGBA{Float32}(0,0,1,1),\n    ]\n    poses = visualize((Sphere(Point3f0(0), 0.05f0), positions))\n    lines = visualize(lines, :linesegment, color=colors)\n    Context(poses, lines)\nend\n\n# add the camera to the camera screen as the perspective camera\ncamera_screen.cameras[:perspective] = cam\n\n# something to look at\ncat = visualize(GLNormalMesh(loadasset( cat.obj )))\n\n# visualize the camera path\ncamera_points = visualize(\n    (Circle(Point2f0(0), 0.03f0), camera_path),\n    color=RGBA{Float32}((Vec3f0(0,206,209)/256)..., 1f0), billboard=true\n)\ncamera_path_line = visualize(camera_path, :lines) \nCopy function for a context. We only need to copy the uniform dict \nfunction copy(c::GLAbstraction.Context)\n    a = c.children[]\n    uniforms = Dict{Symbol, Any}([k= v for (k,v) in a.uniforms])\n    robj = RenderObject(\n        a.main,\n        uniforms,\n        a.vertexarray,\n        a.prerenderfunctions,\n        a.postrenderfunctions,\n        a.id,\n        a.boundingbox,\n    )\n    Context(robj)\nend\n\n# view everything on the appropriate screen.\n# we need to copy the cat, because view inserts the camera into the\n# actual render object. this is sub optimal and will get changed!\n# Note, that this is a shallow copy, so the actual data won't be copied,\n# just the data structure that holds the camera\nview(copy(cat), camera_screen, camera=:perspective)\n\nview(copy(cat), scene_screen, camera=:perspective)\n\nview(visualize(cam), scene_screen, camera=:perspective)\n\nview(camera_points, scene_screen, camera=:perspective)\nview(camera_path_line, scene_screen, camera=:perspective)\n\n\n\nrenderloop(window)", 
            "title": "Camera"
        }, 
        {
            "location": "/examples/camera/#camera2", 
            "text": "using GLVisualize, GLAbstraction, FileIO, GeometryTypes, Reactive\n\nw = glscreen()\n\nrobj         = visualize(rand(Float32, 32,32), :surface)\nbb           = boundingbox(robj).value\nbb_width     = widths(bb)\nlower_corner = minimum(bb)\nmiddle       = lower_corner + (bb_width/2f0)\nlookatvec    = Signal(Vec3f0(0))\neyeposition  = Signal(Vec3f0(2))\n\nideal_eyepos = middle + (norm(bb_width)*Vec3f0(2,0,2))\n\n\ntheta, translation = GLAbstraction.default_camera_control(\n    w.inputs, Signal(0.1f0), Signal(0.01f0)\n)\nupvector     = Signal(Vec3f0(0,0,1))\n\ncam = PerspectiveCamera(\n    theta,\n    translation,\n    lookatvec,\n    eyeposition,\n    upvector,\n    w.inputs[:window_area],\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0) # Max distance (clip distance)\n)\n\nw.cameras[:my_cam] = cam\n\nview(robj, camera=:my_cam)\n\n@async renderloop(w)", 
            "title": "Camera2"
        }, 
        {
            "location": "/examples/compose/", 
            "text": "Barplot\n\n\n\n\nusing Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Gadfly, DataFrames, RDatasets\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot(dataset(\ncar\n, \nSLID\n), x=\nWages\n, color=\nLanguage\n, Geom.histogram)\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nCatgraph\n\n\n\n\nusing Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\np = plot(x=1:100, y=2.^rand(100),\n     Scale.y_sqrt, Geom.point, Geom.smooth,\n     Guide.xlabel(\nStimulus\n), Guide.ylabel(\nResponse\n), Guide.title(\nCat Training\n))\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nCompose\n\n\nusing Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Compose\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\np = compose(context(0.0mm, 0.0mm, 200mm, 200mm),\n    rectangle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1], [0.1]),\n    fill([LCHab(92, 10, 77), LCHab(68, 74, 192), LCHab(78, 84, 29)]),\n    stroke([LCHab(5, 0, 77),LCHab(5, 77, 77),LCHab(50, 0, 8)]),\n    (context(), circle(), fill(\nbisque\n)),\n    (context(), rectangle(), fill(\ntomato\n))\n)\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nErrorbar\n\n\n\n\nusing GLVisualize.ComposeBackend, Gadfly, Distributions\nusing Colors, GLVisualize\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nsds = [1, 1/2, 1/4, 1/8, 1/16, 1/32]\nn = 10\nys = [mean(rand(Distributions.Normal(0, sd), n)) for sd in sds]\nymins = ys .- (1.96 * sds / sqrt(n))\nymaxs = ys .+ (1.96 * sds / sqrt(n))\n\np = plot(x=1:length(sds), y=ys, ymin=ymins, ymax=ymaxs,\n     Geom.point, Geom.errorbar)\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nRegression\n\n\n\n\nusing GLVisualize.ComposeBackend, Gadfly\nusing Colors, GLVisualize\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\nusing Distributions\nx1 = rand(40)\ny1 = 4.*x1 .+ 2 .+randn(40)\nx2 = rand(40)\ny2 = -6.*x2 .+ 3 .+ randn(40)\nx  = [x1;x2]\ny  = [y1;y2]\ncol = [fill(\nSlope 4\n,40); fill(\nSlope -6\n,40)]\np = plot(x=x,y=y,colour=col, Geom.point, Geom.smooth(method=:lm))\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nSingraph\n\n\n\n\nusing Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot([sin, cos], 0, 25)\n\ndraw(composebackend, p)\nrenderloop(window)\n\n\n\n\n\nSin Dataframe\n\n\n\n\nusing Colors, GLVisualize\nusing DataFrames, Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nxs = 0:0.1:20\n\ndf_cos = DataFrame(\n    x=xs,\n    y=cos(xs),\n    ymin=cos(xs) .- 0.5,\n    ymax=cos(xs) .+ 0.5,\n    f=\ncos\n\n)\ndf_sin = DataFrame(\n    x=xs,\n    y=sin(xs),\n    ymin=sin(xs) .- 0.5,\n    ymax=sin(xs) .+ 0.5,\n    f=\nsin\n\n)\ndf = vcat(df_cos, df_sin)\np = plot(df, x=:x, y=:y, ymin=:ymin, ymax=:ymax, color=:f, Geom.line, Geom.ribbon)\n\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Compose"
        }, 
        {
            "location": "/examples/compose/#barplot", 
            "text": "using Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Gadfly, DataFrames, RDatasets\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot(dataset( car ,  SLID ), x= Wages , color= Language , Geom.histogram)\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Barplot"
        }, 
        {
            "location": "/examples/compose/#catgraph", 
            "text": "using Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\np = plot(x=1:100, y=2.^rand(100),\n     Scale.y_sqrt, Geom.point, Geom.smooth,\n     Guide.xlabel( Stimulus ), Guide.ylabel( Response ), Guide.title( Cat Training ))\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Catgraph"
        }, 
        {
            "location": "/examples/compose/#compose", 
            "text": "using Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Compose\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\np = compose(context(0.0mm, 0.0mm, 200mm, 200mm),\n    rectangle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1], [0.1]),\n    fill([LCHab(92, 10, 77), LCHab(68, 74, 192), LCHab(78, 84, 29)]),\n    stroke([LCHab(5, 0, 77),LCHab(5, 77, 77),LCHab(50, 0, 8)]),\n    (context(), circle(), fill( bisque )),\n    (context(), rectangle(), fill( tomato ))\n)\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Compose"
        }, 
        {
            "location": "/examples/compose/#errorbar", 
            "text": "using GLVisualize.ComposeBackend, Gadfly, Distributions\nusing Colors, GLVisualize\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nsds = [1, 1/2, 1/4, 1/8, 1/16, 1/32]\nn = 10\nys = [mean(rand(Distributions.Normal(0, sd), n)) for sd in sds]\nymins = ys .- (1.96 * sds / sqrt(n))\nymaxs = ys .+ (1.96 * sds / sqrt(n))\n\np = plot(x=1:length(sds), y=ys, ymin=ymins, ymax=ymaxs,\n     Geom.point, Geom.errorbar)\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Errorbar"
        }, 
        {
            "location": "/examples/compose/#regression", 
            "text": "using GLVisualize.ComposeBackend, Gadfly\nusing Colors, GLVisualize\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\nusing Distributions\nx1 = rand(40)\ny1 = 4.*x1 .+ 2 .+randn(40)\nx2 = rand(40)\ny2 = -6.*x2 .+ 3 .+ randn(40)\nx  = [x1;x2]\ny  = [y1;y2]\ncol = [fill( Slope 4 ,40); fill( Slope -6 ,40)]\np = plot(x=x,y=y,colour=col, Geom.point, Geom.smooth(method=:lm))\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Regression"
        }, 
        {
            "location": "/examples/compose/#singraph", 
            "text": "using Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot([sin, cos], 0, 25)\n\ndraw(composebackend, p)\nrenderloop(window)", 
            "title": "Singraph"
        }, 
        {
            "location": "/examples/compose/#sin-dataframe", 
            "text": "using Colors, GLVisualize\nusing DataFrames, Gadfly, GLVisualize.ComposeBackend\n\nwindow = glscreen()\ncomposebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nxs = 0:0.1:20\n\ndf_cos = DataFrame(\n    x=xs,\n    y=cos(xs),\n    ymin=cos(xs) .- 0.5,\n    ymax=cos(xs) .+ 0.5,\n    f= cos \n)\ndf_sin = DataFrame(\n    x=xs,\n    y=sin(xs),\n    ymin=sin(xs) .- 0.5,\n    ymax=sin(xs) .+ 0.5,\n    f= sin \n)\ndf = vcat(df_cos, df_sin)\np = plot(df, x=:x, y=:y, ymin=:ymin, ymax=:ymax, color=:f, Geom.line, Geom.ribbon)\n\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Sin Dataframe"
        }, 
        {
            "location": "/examples/imagelike/", 
            "text": "Contourf\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# use the performance tips to speed this up\n# (http://docs.julialang.org/en/release-0.4/manual/performance-tips/)\n# the array is 512x512 after all\nconst N = 512\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Intensity{1,Float32}(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Intensity{1,Float32}, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nrenderable = visualize(map(contourdata, timesignal))\n\nview(renderable, window, camera=:orthographic_pixel)\n\nrenderloop(window)\n\n\n\n\n\nImageio\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\nwindow = glscreen()\n\n# a few helper functions to generate images\ntypealias NColor{N, T} Colorant{T, N}\nfillcolor{T \n: NColor{4}}(::Type{T}) = T(0,1,0,1)\nfillcolor{T \n: NColor{3}}(::Type{T}) = T(0,1,0)\n\n# create different images with different color types (not an exhaustive list of supported types)\narrays = map((RGBA{U8}, RGBA{Float32}, RGB{U8}, RGB{Float32}, BGRA{U8}, BGR{Float32})) do C\n     C[fillcolor(C) for x=1:45,y=1:45]\n end\n# load a few images from the asset folder with FileIO.load (that's what loadasset calls)\nloaded_imgs = map(x-\nloadasset(\ntest_images\n, x), readdir(assetpath(\ntest_images\n)))\n\n# combine them all into one array and add an animated gif and a few other images\nx = Any[\n    arrays..., loaded_imgs...,\n    loadasset(\nkittens-look.gif\n),\n    loadasset(\nmario\n, \nstand\n, \nright.png\n),\n    loadasset(\nmario\n, \njump\n, \nleft.gif\n),\n]\n\n# visualize all images and convert the array to be a vector of element type context\n# This shouldn't be necessary, but it seems map is not able to infer the type alone\nimages = convert(Vector{Context}, map(visualize, x))\n# make it a grid\nimages = reshape(images, (4,4))\n# GLVisualize offers a few helpers to visualize arrays of render objects\n# spaced out as the underlying array. So this will create a grid whereas every\n# item is 128x128x128 pixels big\nimg_vis = visualize(images, scale=Vec3f0(128))\nview(img_vis, window)\n\n\n\nrenderloop(window)\n\n\n\n\n\nParametric Fun\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# create a glsl fragment shader\nparametric_func = frag\n\n    uniform float arg1; // you can add arbitrary uniforms and supply them via the keyword args\n    float function(float x) {\n     return arg1*sin(1/tan(x));\n   }\n\n\n# view the function on a 1700x800 pixel plane\nparemetric = visualize(parametric_func, arg1=timesignal, dimensions=(1700, 800))\nview(paremetric, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Imagelike"
        }, 
        {
            "location": "/examples/imagelike/#contourf", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# use the performance tips to speed this up\n# (http://docs.julialang.org/en/release-0.4/manual/performance-tips/)\n# the array is 512x512 after all\nconst N = 512\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Intensity{1,Float32}(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Intensity{1,Float32}, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nrenderable = visualize(map(contourdata, timesignal))\n\nview(renderable, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Contourf"
        }, 
        {
            "location": "/examples/imagelike/#imageio", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\nwindow = glscreen()\n\n# a few helper functions to generate images\ntypealias NColor{N, T} Colorant{T, N}\nfillcolor{T  : NColor{4}}(::Type{T}) = T(0,1,0,1)\nfillcolor{T  : NColor{3}}(::Type{T}) = T(0,1,0)\n\n# create different images with different color types (not an exhaustive list of supported types)\narrays = map((RGBA{U8}, RGBA{Float32}, RGB{U8}, RGB{Float32}, BGRA{U8}, BGR{Float32})) do C\n     C[fillcolor(C) for x=1:45,y=1:45]\n end\n# load a few images from the asset folder with FileIO.load (that's what loadasset calls)\nloaded_imgs = map(x- loadasset( test_images , x), readdir(assetpath( test_images )))\n\n# combine them all into one array and add an animated gif and a few other images\nx = Any[\n    arrays..., loaded_imgs...,\n    loadasset( kittens-look.gif ),\n    loadasset( mario ,  stand ,  right.png ),\n    loadasset( mario ,  jump ,  left.gif ),\n]\n\n# visualize all images and convert the array to be a vector of element type context\n# This shouldn't be necessary, but it seems map is not able to infer the type alone\nimages = convert(Vector{Context}, map(visualize, x))\n# make it a grid\nimages = reshape(images, (4,4))\n# GLVisualize offers a few helpers to visualize arrays of render objects\n# spaced out as the underlying array. So this will create a grid whereas every\n# item is 128x128x128 pixels big\nimg_vis = visualize(images, scale=Vec3f0(128))\nview(img_vis, window)\n\n\n\nrenderloop(window)", 
            "title": "Imageio"
        }, 
        {
            "location": "/examples/imagelike/#parametric-fun", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# create a glsl fragment shader\nparametric_func = frag \n    uniform float arg1; // you can add arbitrary uniforms and supply them via the keyword args\n    float function(float x) {\n     return arg1*sin(1/tan(x));\n   } \n# view the function on a 1700x800 pixel plane\nparemetric = visualize(parametric_func, arg1=timesignal, dimensions=(1700, 800))\nview(paremetric, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Parametric Fun"
        }, 
        {
            "location": "/examples/interactive/", 
            "text": "Color Edit\n\n\nusing GLVisualize, Colors, ModernGL, GeometryTypes, GLAbstraction, GLWindow, FileIO\nw = glscreen()\nv, colortex = vizzedit(map(RGBA{U8}, colormap(\nblues\n, 7)), w)\n\nrobj = visualize(rand(Float32, 32,32), color_map=colortex, color_norn=Vec2f0(0,2))\nview(robj, w)\nview(v, w, camera=:fixed_pixel)\n\nrenderloop(w)\n\n\n\n\n\nGraph Editing\n\n\n Your browser does not support the video tag. \n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, Reactive, GLWindow, GLFW\n\nwindow = glscreen()\n\nn = 50\nn_connections = 100\na = rand(Point2f0, n)*1000f0\npoints = visualize((Circle(Point2f0(0), 15f0), a))\n\nconst point_robj = points.children[] # temporary way of getting the render object. Shouldn't stay like this\n # best way to get the gpu object. One could also start by creating a gpu array oneself.\n # this is a bit tricky, since not there are three different types.\n # for points and lines you need a GLBuffer. e.g gpu_position = GLBuffer(rand(Point2f0, 50)*1000f0)\nconst gpu_position = point_robj[:position]\n# now the lines and points share the same gpu object\n# for linesegments, you can pass indices, which needs to be of some 32bit int type\nlines  = visualize(gpu_position, :linesegment, indices=rand(1:n, n_connections))\n\n# current tuple of renderobject id and index into the gpu array\nconst m2id = GLWindow.mouse2id(window)\nisoverpoint = const_lift(is_same_id, m2id, point_robj)\n\n# inputs are a dict, materialize gets the keys out of it (equivalent to mouseposition = window.inputs[:mouseposition])\n@materialize mouse_buttons_pressed, mouseposition = window.inputs\n\n# single left mousekey pressed (while no other mouse key is pressed)\nkey_pressed = const_lift(GLAbstraction.singlepressed, mouse_buttons_pressed, GLFW.MOUSE_BUTTON_LEFT)\n# dragg while key_pressed. Drag only starts if isoverpoint is true\nmousedragg  = GLAbstraction.dragged(mouseposition, key_pressed, isoverpoint)\n\n# use mousedrag and mouseid + index to actually change the gpu array with the positions\npreserve(foldp((value(m2id)..., Point2f0(0)), mousedragg) do v0, dragg\n    if dragg == Vec2f0(0) # if drag just started. Not the best way, maybe dragged should return a tuple of (draggvalue, started)\n        id, index = value(m2id)\n        if id==point_robj.id \n length(gpu_position) \n= index\n            p0 = gpu_position[index]\n        else\n            p0 = v0[3]\n        end\n    else\n        id, index, p0 = v0\n        if id==point_robj.id \n length(gpu_position) \n= index\n            gpu_position[index] = Point2f0(p0) + Point2f0(dragg)\n        end\n\n    end\n    return id, index, p0\nend)\n# view it!\nview(lines, window, camera=:fixed_pixel)\nview(points, window, camera=:fixed_pixel)\n\nrenderloop(window)\n\n\n\n\n\nImage Processing\n\n\n Your browser does not support the video tag. \n\n\n\nusing Images, Colors, GeometryTypes\nusing Reactive, FileIO, GLVisualize\nusing GLAbstraction, GeometryTypes, GLWindow\n\nwindow = glscreen()\n\n# loadasset loads data from the GLVisualize asset folder and is defined as\n# FileIO.load(assetpath(name))\ndoge = loadasset(\ndoge.png\n)\n# Convert to RGBA{Float32}. Float for filtering and 32 because it fits the GPU better\nimg = map(RGBA{Float32}, doge)\n# create a slider that goes from 1-20 in 0.1 steps\nslider_s, slider = vizzedit(1f0:0.1f0:20f0, window)\n\n# performant conversion to RGBAU8, implemted with a functor\n# in 0.5 anonymous functions offer the same speed, so this wouldn't be needed\nimmutable ClampRGBAU8 end\ncall(::ClampRGBAU8, x) = RGBA{U8}(clamp(comp1(x), 0,1), clamp(comp2(x), 0,1), clamp(comp3(x), 0,1), clamp(alpha(x), 0,1))\n\n\n\nApplies a gaussian filter to `img` and converts it to RGBA{U8}\n\n\nfunction myfilter(img, sigma)\n    img = Images.imfilter_gaussian(img, [sigma, sigma])\n    map(ClampRGBAU8(), img).data\nend\n\n\nstartvalue = myfilter(img, value(slider_s))\n# Use Reactive.async_map, to filter the image without blocking the main process\ntask, imgsig = async_map(myfilter, startvalue, Signal(img), slider_s)\n# visualize the image signal\nimage_renderable = visualize(imgsig, model=translationmatrix(Vec3f0(50,100,0)))\nview(image_renderable)\n\nvec2i(a,b,x...) = Vec{2,Int}(round(Int, a), round(Int, b))\nvec2i(vec::Vec) = vec2i(vec...)\n\n\ncreates a rectangle around `robj`\n\n\nfunction screen(robj)\n    bb = value(boundingbox(robj))\n    m  = vec2i(minimum(bb))\n    area = SimpleRectangle{Float32}(0,0, ((vec2i(maximum(bb))-m)+30)...)\n\n    view(visualize((area, [Point2f0(0)]),\n        color=RGBA{Float32}(0,0,0,0), stroke_color=RGBA{Float32}(0,0,0,0.7),\n        stroke_width=2f0),\n        camera=:fixed_pixel\n    )\n    robj.children[][:model] = translationmatrix(Vec3f0(15,15,0)-minimum(bb))\n    view(robj, camera=:fixed_pixel)\nend\nscreen(slider)\n\nrenderloop(window)\n\n\n\n\n\nMario Game\n\n\n Your browser does not support the video tag. \n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, ImageMagick\nusing FileIO, ColorTypes, Reactive\n\nwindow = glscreen()\n\ntype Mario{T}\n    x           ::T\n    y           ::T\n    vx          ::T\n    vy          ::T\n    direction   ::Symbol\nend\n\n\n\ngravity(dt, mario) = (mario.vy = (mario.y \n 0.0 ? mario.vy - (dt/4.0) : 0.0); mario)\n\nfunction physics(dt, mario)\n    mario.x = mario.x + dt * mario.vx\n    mario.y = max(0.0, mario.y + dt * mario.vy)\n    mario\nend\n\nfunction walk(keys, mario)\n    mario.vx = keys[1]\n    mario.direction = keys[1] \n 0.0 ? :left : keys[1] \n 0.0 ? :right : mario.direction\n    mario\nend\n\nfunction jump(keys, mario)\n    if keys[2] \n 0.0 \n mario.vy == 0.0\n        mario.vy = 6.0\n    end\n    mario\nend\n\nfunction update(dt, keys, mario)\n    mario = gravity(dt, mario)\n    mario = jump(keys,  mario)\n    mario = walk(keys,  mario)\n    mario = physics(dt, mario)\n    mario\nend\n\n\n\nmario2model(mario) = translationmatrix(Vec3f0(mario.x, mario.y, 0f0))*scalematrix(Vec3f0(5f0))\n\nconst mario_images = Dict()\n\n\nfunction play(x::Vector)\n    const_lift(getindex, x, loop(1:length(x)))\nend\n\nfunction read_sequence(path)\n    if isdir(path)\n        return map(load, sort(map(x-\njoinpath(path, x), readdir(path))))\n    else\n        return fill(load(path), 1)\n    end\nend\n\nfor verb in [\njump\n, \nwalk\n, \nstand\n], dir in [\nleft\n, \nright\n]\n    pic = dir\n    if verb != \nwalk\n # not a sequemce\n        pic *= \n.png\n\n    end\n    path = assetpath(\nmario\n, verb, pic)\n    sequence = read_sequence(path)\n    gif = map(img-\nmap(RGBA{U8}, img), sequence)\n    mario_images[verb*dir] = play(gif)\nend\nfunction mario2image(mario, images=mario_images)\n    verb = mario.y \n 0.0 ? \njump\n : mario.vx != 0.0 ? \nwalk\n : \nstand\n\n    mario_images[verb*string(mario.direction)].value # is a signal of pictures itself (animation), so .value samples the current image\nend\nfunction arrows2vec(direction)\n    direction == :up    \n return Vec2f0( 0.0,  1.0)\n    direction == :down  \n return Vec2f0( 0.0, -1.0)\n    direction == :right \n return Vec2f0( 3.0,  0.0)\n    direction == :left  \n return Vec2f0(-3.0,  0.0)\n    Vec2f0(0.0)\nend\n\n# Put everything together\narrows          = sampleon(bounce(1:10), window.inputs[:arrow_navigation])\nkeys            = const_lift(arrows2vec, arrows)\nmario_signal    = const_lift(update, 8.0, keys, Mario(0.0, 0.0, 0.0, 0.0, :right))\nimage_stream    = const_lift(mario2image, mario_signal)\nmodelmatrix     = const_lift(mario2model, mario_signal)\n\nmario = visualize(image_stream, model=modelmatrix)\n\nview(mario, window, camera=:fixed_pixel)\n\nrenderloop(window)", 
            "title": "Interactive"
        }, 
        {
            "location": "/examples/interactive/#color-edit", 
            "text": "using GLVisualize, Colors, ModernGL, GeometryTypes, GLAbstraction, GLWindow, FileIO\nw = glscreen()\nv, colortex = vizzedit(map(RGBA{U8}, colormap( blues , 7)), w)\n\nrobj = visualize(rand(Float32, 32,32), color_map=colortex, color_norn=Vec2f0(0,2))\nview(robj, w)\nview(v, w, camera=:fixed_pixel)\n\nrenderloop(w)", 
            "title": "Color Edit"
        }, 
        {
            "location": "/examples/interactive/#graph-editing", 
            "text": "Your browser does not support the video tag.   using GeometryTypes, GLVisualize, GLAbstraction, Reactive, GLWindow, GLFW\n\nwindow = glscreen()\n\nn = 50\nn_connections = 100\na = rand(Point2f0, n)*1000f0\npoints = visualize((Circle(Point2f0(0), 15f0), a))\n\nconst point_robj = points.children[] # temporary way of getting the render object. Shouldn't stay like this\n # best way to get the gpu object. One could also start by creating a gpu array oneself.\n # this is a bit tricky, since not there are three different types.\n # for points and lines you need a GLBuffer. e.g gpu_position = GLBuffer(rand(Point2f0, 50)*1000f0)\nconst gpu_position = point_robj[:position]\n# now the lines and points share the same gpu object\n# for linesegments, you can pass indices, which needs to be of some 32bit int type\nlines  = visualize(gpu_position, :linesegment, indices=rand(1:n, n_connections))\n\n# current tuple of renderobject id and index into the gpu array\nconst m2id = GLWindow.mouse2id(window)\nisoverpoint = const_lift(is_same_id, m2id, point_robj)\n\n# inputs are a dict, materialize gets the keys out of it (equivalent to mouseposition = window.inputs[:mouseposition])\n@materialize mouse_buttons_pressed, mouseposition = window.inputs\n\n# single left mousekey pressed (while no other mouse key is pressed)\nkey_pressed = const_lift(GLAbstraction.singlepressed, mouse_buttons_pressed, GLFW.MOUSE_BUTTON_LEFT)\n# dragg while key_pressed. Drag only starts if isoverpoint is true\nmousedragg  = GLAbstraction.dragged(mouseposition, key_pressed, isoverpoint)\n\n# use mousedrag and mouseid + index to actually change the gpu array with the positions\npreserve(foldp((value(m2id)..., Point2f0(0)), mousedragg) do v0, dragg\n    if dragg == Vec2f0(0) # if drag just started. Not the best way, maybe dragged should return a tuple of (draggvalue, started)\n        id, index = value(m2id)\n        if id==point_robj.id   length(gpu_position)  = index\n            p0 = gpu_position[index]\n        else\n            p0 = v0[3]\n        end\n    else\n        id, index, p0 = v0\n        if id==point_robj.id   length(gpu_position)  = index\n            gpu_position[index] = Point2f0(p0) + Point2f0(dragg)\n        end\n\n    end\n    return id, index, p0\nend)\n# view it!\nview(lines, window, camera=:fixed_pixel)\nview(points, window, camera=:fixed_pixel)\n\nrenderloop(window)", 
            "title": "Graph Editing"
        }, 
        {
            "location": "/examples/interactive/#image-processing", 
            "text": "Your browser does not support the video tag.   using Images, Colors, GeometryTypes\nusing Reactive, FileIO, GLVisualize\nusing GLAbstraction, GeometryTypes, GLWindow\n\nwindow = glscreen()\n\n# loadasset loads data from the GLVisualize asset folder and is defined as\n# FileIO.load(assetpath(name))\ndoge = loadasset( doge.png )\n# Convert to RGBA{Float32}. Float for filtering and 32 because it fits the GPU better\nimg = map(RGBA{Float32}, doge)\n# create a slider that goes from 1-20 in 0.1 steps\nslider_s, slider = vizzedit(1f0:0.1f0:20f0, window)\n\n# performant conversion to RGBAU8, implemted with a functor\n# in 0.5 anonymous functions offer the same speed, so this wouldn't be needed\nimmutable ClampRGBAU8 end\ncall(::ClampRGBAU8, x) = RGBA{U8}(clamp(comp1(x), 0,1), clamp(comp2(x), 0,1), clamp(comp3(x), 0,1), clamp(alpha(x), 0,1)) \nApplies a gaussian filter to `img` and converts it to RGBA{U8} \nfunction myfilter(img, sigma)\n    img = Images.imfilter_gaussian(img, [sigma, sigma])\n    map(ClampRGBAU8(), img).data\nend\n\n\nstartvalue = myfilter(img, value(slider_s))\n# Use Reactive.async_map, to filter the image without blocking the main process\ntask, imgsig = async_map(myfilter, startvalue, Signal(img), slider_s)\n# visualize the image signal\nimage_renderable = visualize(imgsig, model=translationmatrix(Vec3f0(50,100,0)))\nview(image_renderable)\n\nvec2i(a,b,x...) = Vec{2,Int}(round(Int, a), round(Int, b))\nvec2i(vec::Vec) = vec2i(vec...) \ncreates a rectangle around `robj` \nfunction screen(robj)\n    bb = value(boundingbox(robj))\n    m  = vec2i(minimum(bb))\n    area = SimpleRectangle{Float32}(0,0, ((vec2i(maximum(bb))-m)+30)...)\n\n    view(visualize((area, [Point2f0(0)]),\n        color=RGBA{Float32}(0,0,0,0), stroke_color=RGBA{Float32}(0,0,0,0.7),\n        stroke_width=2f0),\n        camera=:fixed_pixel\n    )\n    robj.children[][:model] = translationmatrix(Vec3f0(15,15,0)-minimum(bb))\n    view(robj, camera=:fixed_pixel)\nend\nscreen(slider)\n\nrenderloop(window)", 
            "title": "Image Processing"
        }, 
        {
            "location": "/examples/interactive/#mario-game", 
            "text": "Your browser does not support the video tag.   using GeometryTypes, GLVisualize, GLAbstraction, ImageMagick\nusing FileIO, ColorTypes, Reactive\n\nwindow = glscreen()\n\ntype Mario{T}\n    x           ::T\n    y           ::T\n    vx          ::T\n    vy          ::T\n    direction   ::Symbol\nend\n\n\n\ngravity(dt, mario) = (mario.vy = (mario.y   0.0 ? mario.vy - (dt/4.0) : 0.0); mario)\n\nfunction physics(dt, mario)\n    mario.x = mario.x + dt * mario.vx\n    mario.y = max(0.0, mario.y + dt * mario.vy)\n    mario\nend\n\nfunction walk(keys, mario)\n    mario.vx = keys[1]\n    mario.direction = keys[1]   0.0 ? :left : keys[1]   0.0 ? :right : mario.direction\n    mario\nend\n\nfunction jump(keys, mario)\n    if keys[2]   0.0   mario.vy == 0.0\n        mario.vy = 6.0\n    end\n    mario\nend\n\nfunction update(dt, keys, mario)\n    mario = gravity(dt, mario)\n    mario = jump(keys,  mario)\n    mario = walk(keys,  mario)\n    mario = physics(dt, mario)\n    mario\nend\n\n\n\nmario2model(mario) = translationmatrix(Vec3f0(mario.x, mario.y, 0f0))*scalematrix(Vec3f0(5f0))\n\nconst mario_images = Dict()\n\n\nfunction play(x::Vector)\n    const_lift(getindex, x, loop(1:length(x)))\nend\n\nfunction read_sequence(path)\n    if isdir(path)\n        return map(load, sort(map(x- joinpath(path, x), readdir(path))))\n    else\n        return fill(load(path), 1)\n    end\nend\n\nfor verb in [ jump ,  walk ,  stand ], dir in [ left ,  right ]\n    pic = dir\n    if verb !=  walk  # not a sequemce\n        pic *=  .png \n    end\n    path = assetpath( mario , verb, pic)\n    sequence = read_sequence(path)\n    gif = map(img- map(RGBA{U8}, img), sequence)\n    mario_images[verb*dir] = play(gif)\nend\nfunction mario2image(mario, images=mario_images)\n    verb = mario.y   0.0 ?  jump  : mario.vx != 0.0 ?  walk  :  stand \n    mario_images[verb*string(mario.direction)].value # is a signal of pictures itself (animation), so .value samples the current image\nend\nfunction arrows2vec(direction)\n    direction == :up      return Vec2f0( 0.0,  1.0)\n    direction == :down    return Vec2f0( 0.0, -1.0)\n    direction == :right   return Vec2f0( 3.0,  0.0)\n    direction == :left    return Vec2f0(-3.0,  0.0)\n    Vec2f0(0.0)\nend\n\n# Put everything together\narrows          = sampleon(bounce(1:10), window.inputs[:arrow_navigation])\nkeys            = const_lift(arrows2vec, arrows)\nmario_signal    = const_lift(update, 8.0, keys, Mario(0.0, 0.0, 0.0, 0.0, :right))\nimage_stream    = const_lift(mario2image, mario_signal)\nmodelmatrix     = const_lift(mario2model, mario_signal)\n\nmario = visualize(image_stream, model=modelmatrix)\n\nview(mario, window, camera=:fixed_pixel)\n\nrenderloop(window)", 
            "title": "Mario Game"
        }, 
        {
            "location": "/examples/introduction/", 
            "text": "Rotate Robj\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction\nusing FileIO, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n# loadasset is defined in GLVisualize like this:\n# loadasset(path_segments...) = FileIO.load(assetpath(path_segments...))\n# where assetpath just looks up the file in the asset folder\n# You can load these (file types)[https://github.com/JuliaIO/FileIO.jl/blob/master/docs/registry.md]\nmesh            = loadasset(\ncat.obj\n)\n\n# GLAbstraction.const_lift is an alias for Reactive.map, which also works for non\n# signal arguments.\n# Reactive.map takes a function and signals like the one created via `loop` (or just Signal(x))\n# as an argument, applies the function to the signals whenever they update and\n# returns a new signal.\nrotation_angle  = const_lift(*, timesignal, 2f0*pi)\n# the cat needs some rotation on the x axis to stand straight\n# so we start off with a rotation of 90 degrees\nstart_rotation  = Signal(rotationmatrix_x(deg2rad(90f0)))\nrotation        = map(rotationmatrix_y, rotation_angle)\nfinal_rotation  = map(*, start_rotation, rotation)\n\n# now we visualize the mesh and pass the rotation via the model keyword argument,\n# which is short for the modelmatrix, which allows you to transform the visualization\n# with any arbitrary transformation matrix\n# You can create the most common transformation matrix with `translationmatrix(::Vec3f0)`,\n# `rotationmatrix_x`/`y`/`z` (rotation around axis x,y,z), and `scalematrix(::Vec3f0)`\n\n# the visualize function always only takes one argument, plus an optional style\n# argument and then visualization dependant many keywords to customize the visualization.\n# for all parameters Signals can be used and thus the visualization becomes animated\n\nrobj = visualize(mesh, model=final_rotation)\n\n\nview(robj, window)\n\nrenderloop(window)", 
            "title": "Introduction"
        }, 
        {
            "location": "/examples/introduction/#rotate-robj", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction\nusing FileIO, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n# loadasset is defined in GLVisualize like this:\n# loadasset(path_segments...) = FileIO.load(assetpath(path_segments...))\n# where assetpath just looks up the file in the asset folder\n# You can load these (file types)[https://github.com/JuliaIO/FileIO.jl/blob/master/docs/registry.md]\nmesh            = loadasset( cat.obj )\n\n# GLAbstraction.const_lift is an alias for Reactive.map, which also works for non\n# signal arguments.\n# Reactive.map takes a function and signals like the one created via `loop` (or just Signal(x))\n# as an argument, applies the function to the signals whenever they update and\n# returns a new signal.\nrotation_angle  = const_lift(*, timesignal, 2f0*pi)\n# the cat needs some rotation on the x axis to stand straight\n# so we start off with a rotation of 90 degrees\nstart_rotation  = Signal(rotationmatrix_x(deg2rad(90f0)))\nrotation        = map(rotationmatrix_y, rotation_angle)\nfinal_rotation  = map(*, start_rotation, rotation)\n\n# now we visualize the mesh and pass the rotation via the model keyword argument,\n# which is short for the modelmatrix, which allows you to transform the visualization\n# with any arbitrary transformation matrix\n# You can create the most common transformation matrix with `translationmatrix(::Vec3f0)`,\n# `rotationmatrix_x`/`y`/`z` (rotation around axis x,y,z), and `scalematrix(::Vec3f0)`\n\n# the visualize function always only takes one argument, plus an optional style\n# argument and then visualization dependant many keywords to customize the visualization.\n# for all parameters Signals can be used and thus the visualization becomes animated\n\nrobj = visualize(mesh, model=final_rotation)\n\n\nview(robj, window)\n\nrenderloop(window)", 
            "title": "Rotate Robj"
        }, 
        {
            "location": "/examples/lines/", 
            "text": "Contourlines\n\n\n Your browser does not support the video tag. \n\n\n\nusing Contour, GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nxrange = -5f0:0.02f0:5f0\nyrange = -5f0:0.02f0:5f0\n\nz = Float32[sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x) for x in xrange, y in yrange]\nmini = minimum(z)\nmaxi = maximum(z)\ncolor_ramp = map(x-\nRGBA{Float32}(x, 1.0), colormap(\nBlues\n))\nheight2color(val, mini, maxi) = color_ramp[floor(Int, (((val-mini)/(maxi-mini))*(length(color_ramp)-1)))+1]\n\nfor h in mini:0.2f0:maxi\n    c = contour(xrange, yrange, z, h)\n    for elem in c.lines\n        points = map(elem.vertices) do p\n            Point3f0(p, h)\n        end\n        line_renderable = visualize(\n            points, :lines,\n            color=height2color(h, mini, maxi),\n            model=rotation\n        )\n        view(line_renderable, window, camera=:perspective)\n    end\nend\n\nrenderloop(window)\n\n\n\n\n\nLines2D\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\nconst N = 2048\nfunction spiral(i, start_radius, offset)\n    Point2f0(sin(i), cos(i)) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\ncurve_data(i, N) = Point2f0[spiral(i+x/20f0, 1, (i/20)+1) for x=1:N]\n\nt = const_lift(x-\n (1f0-x)*100f0, timesignal)\ncolor = map(RGBA{Float32}, colormap(\nBlues\n, N))\nview(visualize(const_lift(curve_data, t, N), :lines, color=color))\n\n\nrenderloop(window)\n\n\n\n\n\nLines3D\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLAbstraction, Colors, GeometryTypes, GLVisualize, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\n\nn = 400 # The number of points per line\nnloops = 20 # The number of loops\n# The scalar parameter for each line\nTL = linspace(-2f0 * pi, 2f0 * pi, n)\n# We create a list of positions and connections, each describing a line.\n# We will collapse them in one array before plotting.\nxyz    = Point3f0[]\ncolors = RGBA{Float32}[]\n\n# creates some distinguishable colors from which we can sample for each line\nbase_colors1 = distinguishable_colors(nloops, RGB{Float64}(1,0,0))\n# Create each line one after the other in a loop\nfor i=1:nloops\n    append!(xyz, [Point3f0(sin(t), cos((2 + .02 * i) * t), cos((3 + .03 * i) * t)) for t in TL])\n    unique_colors = base_colors1[i]\n    hsv = HSV(unique_colors)\n    color_palette = map(x-\nRGBA{Float32}(x, 1.0), sequential_palette(hsv.h, n, s=hsv.s))\n    append!(colors, color_palette)\nend\n\n# map comes from Reactive.jl and allows you to map any Signal to another.\n# In this case we create a rotation matrix from the timesignal signal.\n\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nlines3d = visualize(xyz, :lines, color=colors, model=rotation)\n\nview(lines3d, window, camera=:perspective)\n\nrenderloop(window)\n\n\n\n\n\nLinesegments3d\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Colors\nusing Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlarge_sphere = HyperSphere(Point3f0(0), 1f0)\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\npositions = decompose(Point3f0, large_sphere)\nindices = rand(range(Cuint(0), Cuint(length(positions))), 1000)\n\ncolor = map(large_sphere-\nRGBA{Float32}(large_sphere, 0.9f0), colormap(\nBlues\n, length(positions)))\ncolor2 = map(large_sphere-\nRGBA{Float32}(large_sphere, 1f0), colormap(\nBlues\n, length(positions)))\n\nlines = visualize(\n    positions, :linesegment, thickness=0.5f0,\n    color=color, indices=indices, model=rotation\n)\nspheres = visualize(\n    (Sphere{Float32}(Point3f0(0.0), 1f0), positions),\n    color=color2, scale=Vec3f0(0.05), model=rotation\n)\nview(lines, window, camera=:perspective)\nview(spheres, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/lines/#contourlines", 
            "text": "Your browser does not support the video tag.   using Contour, GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -  4x4 Float32 rotation matrix\nend\n\nxrange = -5f0:0.02f0:5f0\nyrange = -5f0:0.02f0:5f0\n\nz = Float32[sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x) for x in xrange, y in yrange]\nmini = minimum(z)\nmaxi = maximum(z)\ncolor_ramp = map(x- RGBA{Float32}(x, 1.0), colormap( Blues ))\nheight2color(val, mini, maxi) = color_ramp[floor(Int, (((val-mini)/(maxi-mini))*(length(color_ramp)-1)))+1]\n\nfor h in mini:0.2f0:maxi\n    c = contour(xrange, yrange, z, h)\n    for elem in c.lines\n        points = map(elem.vertices) do p\n            Point3f0(p, h)\n        end\n        line_renderable = visualize(\n            points, :lines,\n            color=height2color(h, mini, maxi),\n            model=rotation\n        )\n        view(line_renderable, window, camera=:perspective)\n    end\nend\n\nrenderloop(window)", 
            "title": "Contourlines"
        }, 
        {
            "location": "/examples/lines/#lines2d", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\nconst N = 2048\nfunction spiral(i, start_radius, offset)\n    Point2f0(sin(i), cos(i)) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\ncurve_data(i, N) = Point2f0[spiral(i+x/20f0, 1, (i/20)+1) for x=1:N]\n\nt = const_lift(x-  (1f0-x)*100f0, timesignal)\ncolor = map(RGBA{Float32}, colormap( Blues , N))\nview(visualize(const_lift(curve_data, t, N), :lines, color=color))\n\n\nrenderloop(window)", 
            "title": "Lines2D"
        }, 
        {
            "location": "/examples/lines/#lines3d", 
            "text": "Your browser does not support the video tag.   using GLAbstraction, Colors, GeometryTypes, GLVisualize, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0.0, 1.0, 360))\n\nn = 400 # The number of points per line\nnloops = 20 # The number of loops\n# The scalar parameter for each line\nTL = linspace(-2f0 * pi, 2f0 * pi, n)\n# We create a list of positions and connections, each describing a line.\n# We will collapse them in one array before plotting.\nxyz    = Point3f0[]\ncolors = RGBA{Float32}[]\n\n# creates some distinguishable colors from which we can sample for each line\nbase_colors1 = distinguishable_colors(nloops, RGB{Float64}(1,0,0))\n# Create each line one after the other in a loop\nfor i=1:nloops\n    append!(xyz, [Point3f0(sin(t), cos((2 + .02 * i) * t), cos((3 + .03 * i) * t)) for t in TL])\n    unique_colors = base_colors1[i]\n    hsv = HSV(unique_colors)\n    color_palette = map(x- RGBA{Float32}(x, 1.0), sequential_palette(hsv.h, n, s=hsv.s))\n    append!(colors, color_palette)\nend\n\n# map comes from Reactive.jl and allows you to map any Signal to another.\n# In this case we create a rotation matrix from the timesignal signal.\n\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -  4x4 Float32 rotation matrix\nend\n\nlines3d = visualize(xyz, :lines, color=colors, model=rotation)\n\nview(lines3d, window, camera=:perspective)\n\nrenderloop(window)", 
            "title": "Lines3D"
        }, 
        {
            "location": "/examples/lines/#linesegments3d", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Colors\nusing Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlarge_sphere = HyperSphere(Point3f0(0), 1f0)\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\npositions = decompose(Point3f0, large_sphere)\nindices = rand(range(Cuint(0), Cuint(length(positions))), 1000)\n\ncolor = map(large_sphere- RGBA{Float32}(large_sphere, 0.9f0), colormap( Blues , length(positions)))\ncolor2 = map(large_sphere- RGBA{Float32}(large_sphere, 1f0), colormap( Blues , length(positions)))\n\nlines = visualize(\n    positions, :linesegment, thickness=0.5f0,\n    color=color, indices=indices, model=rotation\n)\nspheres = visualize(\n    (Sphere{Float32}(Point3f0(0.0), 1f0), positions),\n    color=color2, scale=Vec3f0(0.05), model=rotation\n)\nview(lines, window, camera=:perspective)\nview(spheres, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Linesegments3d"
        }, 
        {
            "location": "/examples/meshes/", 
            "text": "Meshcreation\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors\n\nwindow = glscreen()\n\nbaselen = 0.4f0\ndirlen = 2f0\n# create an array of differently colored boxes in the direction of the 3 axes\nrectangles = [\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(dirlen, baselen, baselen)), RGBA(1f0,0f0,0f0,1f0)),\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(baselen, dirlen, baselen)), RGBA(0f0,1f0,0f0,1f0)),\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(baselen, baselen, dirlen)), RGBA(0f0,0f0,1f0,1f0))\n]\n# convert to an array of normal meshes\n# note, that the constructor is a bit weird. GLNormalMesh takes a tuple of\n# a geometry and a color. This means, the geometry will be converted to a GLNormalMesh\n# and the color will be added afterwards, so the resulting type is a GLNormalColorMesh\nmeshes = map(GLNormalMesh, rectangles)\n# merge them into one big mesh\n# the resulting type is a GLNormalAttributeMesh, since we merged meshes with different\n# attributes (colors). An array of the colors will be created and each vertex in the\n# mesh will be asigned to one of the colors found there.\ncolored_mesh = merge(meshes)\nview(visualize(colored_mesh), window)\n\n# one could also create a GLNormalAttributeMesh manually:\ncolors = RGBA{U8}[RGBA{U8}(rand(), rand(), rand(), 1.0) for i=1:50]\nsphere = Sphere{Float32}(Point3f0(0), 2f0)\n# decompose decomposes a mesh or geometry into the primitive of the first argument\nvertices = decompose(Point3f0, sphere)\nfaces = decompose(GLTriangle, sphere)\n# assign every vertice a random index into the color array (0-based indexes)\nattribute_ids = Float32[rand(0:49) for i=1:length(vertices)]\n\nsphere_mesh = GLNormalAttributeMesh(\n    vertices=vertices, faces=faces,\n    attributes=colors, attribute_id=attribute_ids\n)\n\n# move the model a bit to the right\nmoveright = translationmatrix(Vec3f0(5,0,0))\n\nview(visualize(sphere_mesh, model=moveright), window)\n\nrenderloop(window)\n\n\n\n\n\nMeshes Io\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\n\n# loadasset is defined as `loadasset(name) = load(assetphat(name))`\n# load comes from FileIO, which automatically detects the file format and loads it\n# in general, load will try to load the mesh as is, which may return different\n# meshtypes. This is why it's wrapped into GLNormalMesh, to guarantee some type\n# stability.\n# Formats supported are currently: obj, stl, ply, off and 2DM\nmsh = GLNormalMesh(loadasset(\ncat.obj\n))\n\nview(visualize(msh), window)\n\nrenderloop(window)", 
            "title": "Meshes"
        }, 
        {
            "location": "/examples/meshes/#meshcreation", 
            "text": "using GLVisualize, GeometryTypes, GLAbstraction, Colors\n\nwindow = glscreen()\n\nbaselen = 0.4f0\ndirlen = 2f0\n# create an array of differently colored boxes in the direction of the 3 axes\nrectangles = [\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(dirlen, baselen, baselen)), RGBA(1f0,0f0,0f0,1f0)),\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(baselen, dirlen, baselen)), RGBA(0f0,1f0,0f0,1f0)),\n    (HyperRectangle{3,Float32}(Vec3f0(baselen), Vec3f0(baselen, baselen, dirlen)), RGBA(0f0,0f0,1f0,1f0))\n]\n# convert to an array of normal meshes\n# note, that the constructor is a bit weird. GLNormalMesh takes a tuple of\n# a geometry and a color. This means, the geometry will be converted to a GLNormalMesh\n# and the color will be added afterwards, so the resulting type is a GLNormalColorMesh\nmeshes = map(GLNormalMesh, rectangles)\n# merge them into one big mesh\n# the resulting type is a GLNormalAttributeMesh, since we merged meshes with different\n# attributes (colors). An array of the colors will be created and each vertex in the\n# mesh will be asigned to one of the colors found there.\ncolored_mesh = merge(meshes)\nview(visualize(colored_mesh), window)\n\n# one could also create a GLNormalAttributeMesh manually:\ncolors = RGBA{U8}[RGBA{U8}(rand(), rand(), rand(), 1.0) for i=1:50]\nsphere = Sphere{Float32}(Point3f0(0), 2f0)\n# decompose decomposes a mesh or geometry into the primitive of the first argument\nvertices = decompose(Point3f0, sphere)\nfaces = decompose(GLTriangle, sphere)\n# assign every vertice a random index into the color array (0-based indexes)\nattribute_ids = Float32[rand(0:49) for i=1:length(vertices)]\n\nsphere_mesh = GLNormalAttributeMesh(\n    vertices=vertices, faces=faces,\n    attributes=colors, attribute_id=attribute_ids\n)\n\n# move the model a bit to the right\nmoveright = translationmatrix(Vec3f0(5,0,0))\n\nview(visualize(sphere_mesh, model=moveright), window)\n\nrenderloop(window)", 
            "title": "Meshcreation"
        }, 
        {
            "location": "/examples/meshes/#meshes-io", 
            "text": "using GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\n\n# loadasset is defined as `loadasset(name) = load(assetphat(name))`\n# load comes from FileIO, which automatically detects the file format and loads it\n# in general, load will try to load the mesh as is, which may return different\n# meshtypes. This is why it's wrapped into GLNormalMesh, to guarantee some type\n# stability.\n# Formats supported are currently: obj, stl, ply, off and 2DM\nmsh = GLNormalMesh(loadasset( cat.obj ))\n\nview(visualize(msh), window)\n\nrenderloop(window)", 
            "title": "Meshes Io"
        }, 
        {
            "location": "/examples/particles/", 
            "text": "Bars\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, Colors, GeometryTypes, GLAbstraction, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\nconst N = 87\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Float32(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Float32, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nheightfield = map(contourdata, timesignal)\nmini = Vec3f0(first(range), first(range), minimum(value(heightfield)))\nmaxi = Vec3f0(last(range), last(range), maximum(value(heightfield)))\nbarsvis = visualize(\n    heightfield,\n    scale_x = 0.07,\n    scale_y = 0.07,\n    color_map=map(RGBA{U8}, colormap(\nBlues\n)),\n    color_norm=Vec2f0(0,1),\n    ranges=(range, range),\n    boundingbox=Signal(AABB{Float32}(mini, maxi))\n)\nview(barsvis, window)\n\nrenderloop(window)\n\n\n\n\n\nCubicles\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\ncube = HyperRectangle(Vec3f0(0), Vec3f0(0.05))\nn = 20\nconst wx,wy,wz = widths(cube)\n\nmesh = GLNormalMesh(cube)\n\ntimepi = const_lift(*, timesignal, 2f0*pi)\nfunction position(t, x, y)\n    pos = Point3f0(x*(sqrt(wx^2+wy^2)), -y*wy, y*wz)\n    dir = Point3f0(0, wy, wz)\n    pos = pos + sin(t)*dir\nend\nposition_signal = map(timepi) do t\n    vec(Point3f0[position(t,x,y) for x=1:n, y=1:n])\nend\n\nrotation = map(timepi) do t\n    vec(Vec3f0[Vec3f0(cos(t+(x/7)),sin(t+(y/7)), 1) for x=1:20, y=1:20])\nend\n\ncubes = visualize(\n    (mesh, position_signal),\n    rotation=rotation,\n    color_map=GLVisualize.default(Vector{RGBA}),\n    color_norm=Vec2f0(1,1.8)\n    # intensity that will define the color sampled from color_map will fallback\n    # to the length of the rotation vector.\n    # you could also supply it via intensity = Vector{Float32}\n)\n\n# we create our own camera to better adjust to what we want to see.\ncamera = PerspectiveCamera(\n    Signal(Vec3f0(0)), # theta (rotate by x around cam xyz axis)\n    Signal(Vec3f0(0)), # translation (translate by translation in the direction of the cam xyz axis)\n    Signal(Vec3f0(wx*n+4wx,wy*n,wz*n)/2), # lookat. We want to look at the middle of the cubes\n    Signal(Vec3f0(((wx*n+4wx)/2),1.2*wy*n,(wz*n)/2)), # camera position. We want to be on the same height, but further away in y\n    Signal(Vec3f0(0,0,1)), #upvector\n    window.area, # window area\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0), # Max distance (clip distance)\n    Signal(GLAbstraction.ORTHOGRAPHIC)\n)\nview(cubes, window, camera=camera)\n\n\nrenderloop(window)\n\n\n\n\n\nFlow3D\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nN = 7\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec3f0[(sin(x/t), cos(y/(t/2f0)), sqrt(t+z^2)) for x=1:N, y=1:N, z=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow)\nview(vis, window)\n\nrenderloop(window)\n\n\n\n\n\nParticles\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0, 360))\n\ncat    = GLNormalMesh(loadasset(\ncat.obj\n))\nsphere = GLNormalMesh(Sphere{Float32}(Vec3f0(0), 1f0), 12)\n\nfunction scale_gen(v0, nv)\n    l = length(v0)\n    @inbounds for i=1:l\n        v0[i] = Vec3f0(1,1,sin((nv*l)/i))/2\n    end\n    v0\nend\nfunction color_gen(v0, t)\n    l = length(v0)\n    @inbounds for x=1:l\n        v0[x] = RGBA{U8}(x/l,(cos(t)+1)/2,(sin(x/l/3)+1)/2.,1.)\n    end\n    v0\nend\n\nt            = const_lift(x-\nx+0.1, timesignal)\nps           = sphere.vertices\nscale_start  = Vec3f0[Vec3f0(1,1,rand()) for i=1:length(ps)]\nscale        = foldp(scale_gen, scale_start, t)\ncolorstart   = color_gen(zeros(RGBA{U8}, length(ps)), value(t))\ncolor        = foldp(color_gen, colorstart, t)\nrotation     = -sphere.normals\n\ncats = visualize((cat, ps), scale=scale, color=color, rotation=rotation)\n\nview(cats, window)\n\nrenderloop(window)\n\n\n\n\n\nSinfun\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nt = const_lift(*, timesignal, 20pi)\nn = 50\nconst yrange = linspace(0.03, 0.3, n)\ntrange = linspace(0, 10pi, 200)\n\nfunction gen_points(timesignal, y)\n    x = sin(timesignal+(y*60*pi*y)+y)*y*5\n    z = cos((timesignal+pi)+(y*60*pi*y)+y)*y*5\n    Point3f0(x,y*60f0,z)\nend\nfunction gen_points(timesignal)\n    Point3f0[gen_points(timesignal, y) for y in yrange]\nend\n\npositions = map(gen_points, t)\nscale     = map(Vec3f0, linspace(0.05, 0.6, n))\nprimitive = centered(Sphere)\ncolor     = map(RGB{Float32}, colormap(\nRdBu\n, n))\npoints    = visualize((primitive, positions), scale=scale, color=color)\n\nview(points, window)\n\nrenderloop(window)\n\n\n\n\n\nSphere1Drange\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0,360))\n# last argument can be used to control the granularity of the resulting mesh\nsphere = GLNormalMesh(Sphere(Point3f0(0.5), 0.5f0), 24)\nc = collect(linspace(0.1f0,1.0f0,10f0))\nrotation = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\n# create a visualisation\nvis = visualize((sphere, c), model=rotation, scale_y=0.1f0)\nview(vis, window)\n\nrenderloop(window)", 
            "title": "Particles"
        }, 
        {
            "location": "/examples/particles/#bars", 
            "text": "Your browser does not support the video tag.   using GLVisualize, Colors, GeometryTypes, GLAbstraction, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\nconst N = 87\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Float32(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Float32, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nheightfield = map(contourdata, timesignal)\nmini = Vec3f0(first(range), first(range), minimum(value(heightfield)))\nmaxi = Vec3f0(last(range), last(range), maximum(value(heightfield)))\nbarsvis = visualize(\n    heightfield,\n    scale_x = 0.07,\n    scale_y = 0.07,\n    color_map=map(RGBA{U8}, colormap( Blues )),\n    color_norm=Vec2f0(0,1),\n    ranges=(range, range),\n    boundingbox=Signal(AABB{Float32}(mini, maxi))\n)\nview(barsvis, window)\n\nrenderloop(window)", 
            "title": "Bars"
        }, 
        {
            "location": "/examples/particles/#cubicles", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\ncube = HyperRectangle(Vec3f0(0), Vec3f0(0.05))\nn = 20\nconst wx,wy,wz = widths(cube)\n\nmesh = GLNormalMesh(cube)\n\ntimepi = const_lift(*, timesignal, 2f0*pi)\nfunction position(t, x, y)\n    pos = Point3f0(x*(sqrt(wx^2+wy^2)), -y*wy, y*wz)\n    dir = Point3f0(0, wy, wz)\n    pos = pos + sin(t)*dir\nend\nposition_signal = map(timepi) do t\n    vec(Point3f0[position(t,x,y) for x=1:n, y=1:n])\nend\n\nrotation = map(timepi) do t\n    vec(Vec3f0[Vec3f0(cos(t+(x/7)),sin(t+(y/7)), 1) for x=1:20, y=1:20])\nend\n\ncubes = visualize(\n    (mesh, position_signal),\n    rotation=rotation,\n    color_map=GLVisualize.default(Vector{RGBA}),\n    color_norm=Vec2f0(1,1.8)\n    # intensity that will define the color sampled from color_map will fallback\n    # to the length of the rotation vector.\n    # you could also supply it via intensity = Vector{Float32}\n)\n\n# we create our own camera to better adjust to what we want to see.\ncamera = PerspectiveCamera(\n    Signal(Vec3f0(0)), # theta (rotate by x around cam xyz axis)\n    Signal(Vec3f0(0)), # translation (translate by translation in the direction of the cam xyz axis)\n    Signal(Vec3f0(wx*n+4wx,wy*n,wz*n)/2), # lookat. We want to look at the middle of the cubes\n    Signal(Vec3f0(((wx*n+4wx)/2),1.2*wy*n,(wz*n)/2)), # camera position. We want to be on the same height, but further away in y\n    Signal(Vec3f0(0,0,1)), #upvector\n    window.area, # window area\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0), # Max distance (clip distance)\n    Signal(GLAbstraction.ORTHOGRAPHIC)\n)\nview(cubes, window, camera=camera)\n\n\nrenderloop(window)", 
            "title": "Cubicles"
        }, 
        {
            "location": "/examples/particles/#flow3d", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nN = 7\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec3f0[(sin(x/t), cos(y/(t/2f0)), sqrt(t+z^2)) for x=1:N, y=1:N, z=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow)\nview(vis, window)\n\nrenderloop(window)", 
            "title": "Flow3D"
        }, 
        {
            "location": "/examples/particles/#particles", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0, 360))\n\ncat    = GLNormalMesh(loadasset( cat.obj ))\nsphere = GLNormalMesh(Sphere{Float32}(Vec3f0(0), 1f0), 12)\n\nfunction scale_gen(v0, nv)\n    l = length(v0)\n    @inbounds for i=1:l\n        v0[i] = Vec3f0(1,1,sin((nv*l)/i))/2\n    end\n    v0\nend\nfunction color_gen(v0, t)\n    l = length(v0)\n    @inbounds for x=1:l\n        v0[x] = RGBA{U8}(x/l,(cos(t)+1)/2,(sin(x/l/3)+1)/2.,1.)\n    end\n    v0\nend\n\nt            = const_lift(x- x+0.1, timesignal)\nps           = sphere.vertices\nscale_start  = Vec3f0[Vec3f0(1,1,rand()) for i=1:length(ps)]\nscale        = foldp(scale_gen, scale_start, t)\ncolorstart   = color_gen(zeros(RGBA{U8}, length(ps)), value(t))\ncolor        = foldp(color_gen, colorstart, t)\nrotation     = -sphere.normals\n\ncats = visualize((cat, ps), scale=scale, color=color, rotation=rotation)\n\nview(cats, window)\n\nrenderloop(window)", 
            "title": "Particles"
        }, 
        {
            "location": "/examples/particles/#sinfun", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nt = const_lift(*, timesignal, 20pi)\nn = 50\nconst yrange = linspace(0.03, 0.3, n)\ntrange = linspace(0, 10pi, 200)\n\nfunction gen_points(timesignal, y)\n    x = sin(timesignal+(y*60*pi*y)+y)*y*5\n    z = cos((timesignal+pi)+(y*60*pi*y)+y)*y*5\n    Point3f0(x,y*60f0,z)\nend\nfunction gen_points(timesignal)\n    Point3f0[gen_points(timesignal, y) for y in yrange]\nend\n\npositions = map(gen_points, t)\nscale     = map(Vec3f0, linspace(0.05, 0.6, n))\nprimitive = centered(Sphere)\ncolor     = map(RGB{Float32}, colormap( RdBu , n))\npoints    = visualize((primitive, positions), scale=scale, color=color)\n\nview(points, window)\n\nrenderloop(window)", 
            "title": "Sinfun"
        }, 
        {
            "location": "/examples/particles/#sphere1drange", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0,360))\n# last argument can be used to control the granularity of the resulting mesh\nsphere = GLNormalMesh(Sphere(Point3f0(0.5), 0.5f0), 24)\nc = collect(linspace(0.1f0,1.0f0,10f0))\nrotation = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\n# create a visualisation\nvis = visualize((sphere, c), model=rotation, scale_y=0.1f0)\nview(vis, window)\n\nrenderloop(window)", 
            "title": "Sphere1Drange"
        }, 
        {
            "location": "/examples/screens/", 
            "text": "Screens\n\n\n\n\nusing GLVisualize, Reactive, GeometryTypes\nusing GLWindow, GLAbstraction\n\nwindow = glscreen()\n\n\n\nfunctions to halve some rectangle\n\n\nxhalf(r)  = SimpleRectangle(r.x, r.y, r.w\u00f72, r.h)\nxhalf2(r) = SimpleRectangle(r.w\u00f72, r.y, r.w\u00f72, r.h)\n\n# create first screen with window as the parent screen\n# and a different area.\nscreen2D = Screen(\n    window, name=:screen2D,\n    area=const_lift(xhalf2, window.area)\n)\n# create second screen with window as the parent screen\n# and a different area.\nscreen3D = Screen(\n    window, name=:screen3D,\n    area=const_lift(xhalf, window.area)\n)\n\n# create something to look at!\nbars = visualize(rand(Float32, 10,10))\npoints = visualize([rand(Point2f0)*1000 for i=1:50], scale=Vec2f0(40))\n\n# view them in different screens\nview(bars,   screen3D, camera=:perspective)\nview(points, screen2D, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Screens"
        }, 
        {
            "location": "/examples/screens/#screens", 
            "text": "using GLVisualize, Reactive, GeometryTypes\nusing GLWindow, GLAbstraction\n\nwindow = glscreen() \nfunctions to halve some rectangle \nxhalf(r)  = SimpleRectangle(r.x, r.y, r.w\u00f72, r.h)\nxhalf2(r) = SimpleRectangle(r.w\u00f72, r.y, r.w\u00f72, r.h)\n\n# create first screen with window as the parent screen\n# and a different area.\nscreen2D = Screen(\n    window, name=:screen2D,\n    area=const_lift(xhalf2, window.area)\n)\n# create second screen with window as the parent screen\n# and a different area.\nscreen3D = Screen(\n    window, name=:screen3D,\n    area=const_lift(xhalf, window.area)\n)\n\n# create something to look at!\nbars = visualize(rand(Float32, 10,10))\npoints = visualize([rand(Point2f0)*1000 for i=1:50], scale=Vec2f0(40))\n\n# view them in different screens\nview(bars,   screen3D, camera=:perspective)\nview(points, screen2D, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Screens"
        }, 
        {
            "location": "/examples/sprites/", 
            "text": "Arrows\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\nN = 20\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec2f0[(sin(x/t), cos(y/(t/2f0))) for x=1:N, y=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow, ranges=(50:800,50:500))\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)\n\n\n\n\n\nArrows3d\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n# let the visualization rotate later on\nrotation = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\n# create some random 3D vectors\nvectors3d = rand(Vec3f0, 5,5,5)\n# this is not the best way to use 2D sprites, but this will space them on\n# a 3D grid and use the rotation from `vectors3d` and the length of them\n# to look up the a color from the optional keyword argument `color_map`.\narrows = visualize(('\u27a4', vectors3d), scale=Vec2f0(0.1), model=rotation)\n\nview(arrows, camera=:perspective)\n\nrenderloop(window)\n\n\n\n\n\nBillboard\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, ModernGL, FileIO, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlet\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nconst b = Point3f0[(rand(Point3f0)*2)-1 for i=1:64]\n\nsprites = visualize(\n    (SimpleRectangle(0f0,0f0,0.5f0, 0.5f0), b),\n    billboard=true, image=loadasset(\ndoge.png\n),\n    model=rotation\n)\n\nview(sprites, window, camera=:perspective)\nend\n\nrenderloop(window)\n\n\n\n\n\nBouncy\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,50))\nn = 30\nconst border = 50f0\nfunction bounce_particles(pos_velo, _)\n    positions, velocity = pos_velo\n    dt = 0.1f0\n    @inbounds for i=1:length(positions)\n        pos,velo = positions[i], velocity[i]\n        positions[i] = Point2f0(pos[1], pos[2] + velo*dt)\n        if pos[2] \n= border\n            velocity[i] = abs(velo)\n        else\n            velocity[i] = velo - 9.8*dt\n        end\n    end\n    positions, velocity\nend\nstart_position = (rand(Point2f0, n)*700f0) + border\nposition_velocity = foldp(bounce_particles,\n    (start_position, zeros(Float32, n)),\n    timesignal\n)\ncircle = HyperSphere(Point2f0(0), 40f0)\nvis = visualize((circle, map(first, position_velocity)),\n    image=loadasset(\ndoge.png\n),\n    stroke_width=3f0,\n    stroke_color=RGBA{Float32}(0.91,0.91,0.91,1)\n)\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)\n\n\n\n\n\nDistancefield\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\nconst n1 = 30\npositions = rand(Point2f0, n1).*1000f0\n\n\nxy_data(x,y,i) = Float32(sin(y/2f0/i)+cos(i*x))\nconst n2 = 128\n# a distance field is a Matrix{Float32} array, which encodes the distance to\n# the border of a filled shape. Positive numbers are inside the shape, 0 is the\n# border and negative number are outside.\n# this is basically how we render text, since you can do anti aliasing very\n# nicely when you know the distance to the border.\n# For text we use one big texture and specify uv coordinates into this big texture\n# for every particle. How this is done can be seen in example\n# partices/sprites/image_texture_atlas.jl\n\ndfield = map(timesignal) do t\n    tpi = (2pi*t)+0.2\n    Float32[xy_data(x,y,tpi)+0.5f0 for x=1:n2, y=1:n2]\nend\nBase.rand(m::MersenneTwister, ::Type{U8}) = U8(rand(m, UInt8))\nBase.rand{T \n: Colorant}(m::MersenneTwister, ::Type{T}) = T(ntuple(x-\nrand(m, eltype(T)), Val{length(T)})...)\n\ndistfield = visualize((DISTANCEFIELD, positions),\n    stroke_width=4f0,\n    scale=Vec2f0(120),\n    stroke_color=rand(RGBA{Float32}, n1),\n    color=rand(RGBA{Float32}, n1),\n    distancefield=dfield\n)\nview(distfield, window)\n\n\nrenderloop(window)\n\n\n\n\n\nImage Texture Atlas\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# this is just one big texture\ntexture_atlas = loadasset(\ndoge.png\n)\nw, h = size(texture_atlas)\nconst n = 40\nxrange = linspace(0, w, n)\nyrange = linspace(0, h, n)\nscale  = Vec2f0(step(xrange), step(yrange))\n\n# position in a grid\npositions = map(timesignal) do t\n    vec(Point2f0[(x+(sin(t*2*pi)*400),y+(sin(0+y*t*0.01)*200)+(cos(t*2*pi)*200)) for x=xrange, y=yrange])\nend\n\n# uv coordinates are normalized coordinates into the texture_atlas\n# they need the start point and the width of each rectangle (sprites are rectangles)\n# so you will not actually index with the circle primitive, but rather with\n# with the quad of the particle (the rest of the quad is transparent)\n# note, that for uv coordinates, the origin is on the top left corner\nuv_offset_width = vec(Vec4f0[(x,y,x+(1/n),y+(1/n)) for x=linspace(0, 1, n), y=linspace(1, 0, n)])\n\n# when position and scale are defined, We can leave the middle and radius of\n# Circle undefined, so just passing the type.\ndistfield = visualize((Circle, positions),\n    scale=scale,\n    stroke_width=1f0,\n    uv_offset_width=uv_offset_width,\n    stroke_color = RGBA{Float32}(0.9,0.9,0.9,1.0),\n    image=texture_atlas\n)\nview(distfield, window)\n\n\nrenderloop(window)\n\n\n\n\n\nLetitsnow\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0, 360))\n\nconst S = -5f0\nconst W = 10f0\nconst N = 1000\nconst ps = (rand(Point3f0, N)*W)+S\nconst velocity = rand(Vec3f0, N)*0.01f0\nconst gravity  = Vec3f0(0,0,-0.04)\n\nupper_bound(x) = x\nS+W\nlower_bound(x) = x\nS\nfunction let_it_snow(position, t)\n    @inbounds for i=1:length(ps)\n        pos = Vec(position[i])\n        p = Point3f0(pos+gravity+velocity[i])\n        if any(upper_bound, p) || any(lower_bound, p)\n            position[i] = Point3f0(rand(linspace(S,S+W, 1000)),rand(linspace(S,S+W, 1000)), S+W)\n            velocity[i] = Vec3f0(0)\n        else\n            position[i] = p\n        end\n    end\n    position\nend\nparticles       = foldp(let_it_snow, ps, timesignal)\nrotation        = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\ncolor_ramp      = colormap(\nBlues\n, 50)\ncolors          = RGBA{Float32}[color_ramp[rand(1:50)] for i=1:N]\n\nsnowflakes = visualize(\n    ('\u2744', particles),\n    color=colors,\n    scale=Vec2f0(0.6), billboard=true, model=rotation\n)\n\nview(snowflakes, window, camera=:perspective)\n\n\nrenderloop(window)\n\n\n\n\n\nMoving Bars\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\nwindow = glscreen()\ntimesignal = bounce(0f0:0.1:1f0)\n\nprimitive = SimpleRectangle(0f0,-0.5f0,1f0,1f0)\npositions = rand(10f0:0.01f0:200f0, 10)\n\nfunction interpolate(a, positions, t)\n    [ae+((be-ae)*t) for (ae, be) in zip(a,positions)]\nend\nt = const_lift(*, timesignal, 10f0)\ninterpolated = foldp((positions,positions,positions), t) do v0_v1_ip, td\n    v0,v1,ip = v0_v1_ip\n    pol = td%1\n    if isapprox(pol, 0.0)\n        v0 = v1\n        v1 = map(x-\n rand(linspace(-50f0, 60f0, 100)), v0)\n    end\n    v0, v1, interpolate(v0, v1, pol)\nend\nb_sig = map(last, interpolated)\nbars = visualize(\n    (RECTANGLE, b_sig),\n    intensity=b_sig,\n    ranges=linspace(0,600, 10),\n    color_norm=Vec2f0(-40,200),\n    color_map=GLVisualize.default(Vector{RGBA})\n)\nview(bars, window, camera=:orthographic_pixel)\n\nrenderloop(window)\n\n\n\n\n\nMoving Circles\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nt          = const_lift(*, timesignal, 10f0)\nradius     = 200f0\nw,h        = widths(window)\nmiddle     = Point2f0(w/2, h/2)\ncircle_pos = Point2f0[(Point2f0(sin(i), cos(i))*radius)+middle for i=linspace(0, 2pi, 20)]\nrotation   = Vec2f0[normalize(Vec2f0(middle)-Vec2f0(p)) for p in circle_pos]\nscales     = map(t) do t\n    Vec2f0[Vec2f0(30, ((sin(i+t)+1)/2)*60) for i=linspace(0, 2pi, 20)]\nend\n\ncircles = visualize(\n    (CIRCLE, circle_pos),\n    rotation=rotation, scale=scales,\n)\n\nview(circles, window)\n\nrenderloop(window)\n\n\n\n\n\nParticles2D\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\n\n\nfunction spiral(i, start_radius, offset)\n    Point2f0(sin(i), cos(i)) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\nparticle_data2D(i, N) = Point2f0[spiral(i+x, 3, 10) for x=1:N]\n# stretch time a bit:\nt = const_lift(*, timesignal, 30f0)\n\n# the simplest of all, plain 2D particles.\n# to make it a little more interesting, we animate the particles a bit!\nparticles = const_lift(particle_data2D, t, 256)\n\n# create a visualisation with each particle being 15px wide\n# if you omit the primitive, it defaults to a SimpleRectangle\nvis = visualize(particles, scale=Vec2f0(15))\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Sprites"
        }, 
        {
            "location": "/examples/sprites/#arrows", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\nN = 20\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec2f0[(sin(x/t), cos(y/(t/2f0))) for x=1:N, y=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow, ranges=(50:800,50:500))\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Arrows"
        }, 
        {
            "location": "/examples/sprites/#arrows3d", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n# let the visualization rotate later on\nrotation = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\n# create some random 3D vectors\nvectors3d = rand(Vec3f0, 5,5,5)\n# this is not the best way to use 2D sprites, but this will space them on\n# a 3D grid and use the rotation from `vectors3d` and the length of them\n# to look up the a color from the optional keyword argument `color_map`.\narrows = visualize(('\u27a4', vectors3d), scale=Vec2f0(0.1), model=rotation)\n\nview(arrows, camera=:perspective)\n\nrenderloop(window)", 
            "title": "Arrows3d"
        }, 
        {
            "location": "/examples/sprites/#billboard", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction, ModernGL, FileIO, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlet\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nconst b = Point3f0[(rand(Point3f0)*2)-1 for i=1:64]\n\nsprites = visualize(\n    (SimpleRectangle(0f0,0f0,0.5f0, 0.5f0), b),\n    billboard=true, image=loadasset( doge.png ),\n    model=rotation\n)\n\nview(sprites, window, camera=:perspective)\nend\n\nrenderloop(window)", 
            "title": "Billboard"
        }, 
        {
            "location": "/examples/sprites/#bouncy", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,50))\nn = 30\nconst border = 50f0\nfunction bounce_particles(pos_velo, _)\n    positions, velocity = pos_velo\n    dt = 0.1f0\n    @inbounds for i=1:length(positions)\n        pos,velo = positions[i], velocity[i]\n        positions[i] = Point2f0(pos[1], pos[2] + velo*dt)\n        if pos[2]  = border\n            velocity[i] = abs(velo)\n        else\n            velocity[i] = velo - 9.8*dt\n        end\n    end\n    positions, velocity\nend\nstart_position = (rand(Point2f0, n)*700f0) + border\nposition_velocity = foldp(bounce_particles,\n    (start_position, zeros(Float32, n)),\n    timesignal\n)\ncircle = HyperSphere(Point2f0(0), 40f0)\nvis = visualize((circle, map(first, position_velocity)),\n    image=loadasset( doge.png ),\n    stroke_width=3f0,\n    stroke_color=RGBA{Float32}(0.91,0.91,0.91,1)\n)\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Bouncy"
        }, 
        {
            "location": "/examples/sprites/#distancefield", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\nconst n1 = 30\npositions = rand(Point2f0, n1).*1000f0\n\n\nxy_data(x,y,i) = Float32(sin(y/2f0/i)+cos(i*x))\nconst n2 = 128\n# a distance field is a Matrix{Float32} array, which encodes the distance to\n# the border of a filled shape. Positive numbers are inside the shape, 0 is the\n# border and negative number are outside.\n# this is basically how we render text, since you can do anti aliasing very\n# nicely when you know the distance to the border.\n# For text we use one big texture and specify uv coordinates into this big texture\n# for every particle. How this is done can be seen in example\n# partices/sprites/image_texture_atlas.jl\n\ndfield = map(timesignal) do t\n    tpi = (2pi*t)+0.2\n    Float32[xy_data(x,y,tpi)+0.5f0 for x=1:n2, y=1:n2]\nend\nBase.rand(m::MersenneTwister, ::Type{U8}) = U8(rand(m, UInt8))\nBase.rand{T  : Colorant}(m::MersenneTwister, ::Type{T}) = T(ntuple(x- rand(m, eltype(T)), Val{length(T)})...)\n\ndistfield = visualize((DISTANCEFIELD, positions),\n    stroke_width=4f0,\n    scale=Vec2f0(120),\n    stroke_color=rand(RGBA{Float32}, n1),\n    color=rand(RGBA{Float32}, n1),\n    distancefield=dfield\n)\nview(distfield, window)\n\n\nrenderloop(window)", 
            "title": "Distancefield"
        }, 
        {
            "location": "/examples/sprites/#image-texture-atlas", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# this is just one big texture\ntexture_atlas = loadasset( doge.png )\nw, h = size(texture_atlas)\nconst n = 40\nxrange = linspace(0, w, n)\nyrange = linspace(0, h, n)\nscale  = Vec2f0(step(xrange), step(yrange))\n\n# position in a grid\npositions = map(timesignal) do t\n    vec(Point2f0[(x+(sin(t*2*pi)*400),y+(sin(0+y*t*0.01)*200)+(cos(t*2*pi)*200)) for x=xrange, y=yrange])\nend\n\n# uv coordinates are normalized coordinates into the texture_atlas\n# they need the start point and the width of each rectangle (sprites are rectangles)\n# so you will not actually index with the circle primitive, but rather with\n# with the quad of the particle (the rest of the quad is transparent)\n# note, that for uv coordinates, the origin is on the top left corner\nuv_offset_width = vec(Vec4f0[(x,y,x+(1/n),y+(1/n)) for x=linspace(0, 1, n), y=linspace(1, 0, n)])\n\n# when position and scale are defined, We can leave the middle and radius of\n# Circle undefined, so just passing the type.\ndistfield = visualize((Circle, positions),\n    scale=scale,\n    stroke_width=1f0,\n    uv_offset_width=uv_offset_width,\n    stroke_color = RGBA{Float32}(0.9,0.9,0.9,1.0),\n    image=texture_atlas\n)\nview(distfield, window)\n\n\nrenderloop(window)", 
            "title": "Image Texture Atlas"
        }, 
        {
            "location": "/examples/sprites/#letitsnow", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0, 360))\n\nconst S = -5f0\nconst W = 10f0\nconst N = 1000\nconst ps = (rand(Point3f0, N)*W)+S\nconst velocity = rand(Vec3f0, N)*0.01f0\nconst gravity  = Vec3f0(0,0,-0.04)\n\nupper_bound(x) = x S+W\nlower_bound(x) = x S\nfunction let_it_snow(position, t)\n    @inbounds for i=1:length(ps)\n        pos = Vec(position[i])\n        p = Point3f0(pos+gravity+velocity[i])\n        if any(upper_bound, p) || any(lower_bound, p)\n            position[i] = Point3f0(rand(linspace(S,S+W, 1000)),rand(linspace(S,S+W, 1000)), S+W)\n            velocity[i] = Vec3f0(0)\n        else\n            position[i] = p\n        end\n    end\n    position\nend\nparticles       = foldp(let_it_snow, ps, timesignal)\nrotation        = map(rotationmatrix_z, const_lift(*, timesignal, 2f0*pi))\ncolor_ramp      = colormap( Blues , 50)\ncolors          = RGBA{Float32}[color_ramp[rand(1:50)] for i=1:N]\n\nsnowflakes = visualize(\n    ('\u2744', particles),\n    color=colors,\n    scale=Vec2f0(0.6), billboard=true, model=rotation\n)\n\nview(snowflakes, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Letitsnow"
        }, 
        {
            "location": "/examples/sprites/#moving-bars", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\nwindow = glscreen()\ntimesignal = bounce(0f0:0.1:1f0)\n\nprimitive = SimpleRectangle(0f0,-0.5f0,1f0,1f0)\npositions = rand(10f0:0.01f0:200f0, 10)\n\nfunction interpolate(a, positions, t)\n    [ae+((be-ae)*t) for (ae, be) in zip(a,positions)]\nend\nt = const_lift(*, timesignal, 10f0)\ninterpolated = foldp((positions,positions,positions), t) do v0_v1_ip, td\n    v0,v1,ip = v0_v1_ip\n    pol = td%1\n    if isapprox(pol, 0.0)\n        v0 = v1\n        v1 = map(x-  rand(linspace(-50f0, 60f0, 100)), v0)\n    end\n    v0, v1, interpolate(v0, v1, pol)\nend\nb_sig = map(last, interpolated)\nbars = visualize(\n    (RECTANGLE, b_sig),\n    intensity=b_sig,\n    ranges=linspace(0,600, 10),\n    color_norm=Vec2f0(-40,200),\n    color_map=GLVisualize.default(Vector{RGBA})\n)\nview(bars, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Moving Bars"
        }, 
        {
            "location": "/examples/sprites/#moving-circles", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nt          = const_lift(*, timesignal, 10f0)\nradius     = 200f0\nw,h        = widths(window)\nmiddle     = Point2f0(w/2, h/2)\ncircle_pos = Point2f0[(Point2f0(sin(i), cos(i))*radius)+middle for i=linspace(0, 2pi, 20)]\nrotation   = Vec2f0[normalize(Vec2f0(middle)-Vec2f0(p)) for p in circle_pos]\nscales     = map(t) do t\n    Vec2f0[Vec2f0(30, ((sin(i+t)+1)/2)*60) for i=linspace(0, 2pi, 20)]\nend\n\ncircles = visualize(\n    (CIRCLE, circle_pos),\n    rotation=rotation, scale=scales,\n)\n\nview(circles, window)\n\nrenderloop(window)", 
            "title": "Moving Circles"
        }, 
        {
            "location": "/examples/sprites/#particles2d", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\n\n\nfunction spiral(i, start_radius, offset)\n    Point2f0(sin(i), cos(i)) * (start_radius + ((i/2pi)*offset))\nend\n# 2D particles\nparticle_data2D(i, N) = Point2f0[spiral(i+x, 3, 10) for x=1:N]\n# stretch time a bit:\nt = const_lift(*, timesignal, 30f0)\n\n# the simplest of all, plain 2D particles.\n# to make it a little more interesting, we animate the particles a bit!\nparticles = const_lift(particle_data2D, t, 256)\n\n# create a visualisation with each particle being 15px wide\n# if you omit the primitive, it defaults to a SimpleRectangle\nvis = visualize(particles, scale=Vec2f0(15))\nview(vis, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Particles2D"
        }, 
        {
            "location": "/examples/surfaces/", 
            "text": "Dirac Belt\n\n\n Your browser does not support the video tag. \n\n\n\nusing GeometryTypes, Quaternions, GLVisualize, Reactive, GLAbstraction\n\nfunction Quaternions.qrotation{T\n:Real}(axis::Quaternion{T}, theta::T)\n    ax = Vec{3,T}(axis.v1, axis.v2, axis.v3)\n    qrotation(ax, theta)\nend\n\nfunction Quaternions.qrotation{T\n:Real}(axis::Quaternion{T}, z::Quaternion{T}, theta::T)\n    q = qrotation(axis, theta)\n    q*z*conj(q)\nend\n\nfunction quaternion_belt_trick(timesignal)\n\n    rad1 = 1f0 # outer circle\n    rad2 = 0.2f0 # inner circle\n\n    center1 = Point2f0(rad1,rad1) # left\n    center2 = Point2f0(rad1+2f0,rad1) # right\n\n    u1234 = Quaternion(0f0,0f0,1f0,0f0) # gets rotated\n    axis  = Quaternion(0f0,0f0,0f0,1f0) # axis of qrotationdd\n    mi  = 80\n    mj  = 10\n    rxs = zeros(Float32, mi+1,mj+1)\n    rys = zeros(Float32, mi+1,mj+1)\n    rzs = zeros(Float32, mi+1,mj+1)\n\n    max_frames = 96\n    dphi = 2*pi/(max_frames-1) # include both ends\n\n    u1234_s = foldp(u1234, timesignal) do v0, _\n        qrotation(axis, v0, Float32(dphi))\n    end\n    xyz = const_lift(plot_belts, rxs, rys, rzs, u1234_s, center1, center2, rad1, rad2)\n    x = const_lift(getindex, xyz, 1)\n    y = const_lift(getindex, xyz, 2)\n    z = const_lift(getindex, xyz, 3)\n    (x,y,z)\nend\n\nfunction plot_belts(rxs, rys, rzs, u1234, center1, center2, rad1, rad2)\n    mi  = 80\n    mj  = 10\n    iis = 1f0:(mi+1f0)\n    rs  = rad1-((rad1-rad2)*(iis-1f0)/mi)\n    for ii=1:(mi+1)\n        jjs   = 1f0:(mj+1f0)\n        xs    = (rad2/mj)*((jjs-1f0)-(mj/2f0))\n        ys    = sqrt(rs[ii]*rs[ii]-xs.*xs)\n        theta = Float32(2*pi*(ii-1)/mi)\n\n        for jj=1:(mj+1)\n            efgh    = Quaternion(0f0, xs[jj], ys[jj], 0f0)\n            wxyz    = qrotation(efgh, u1234, theta)\n            rxs[ii,jj] = center1[1]+wxyz.v1\n            rys[ii,jj] = center1[2]+wxyz.v2\n            rzs[ii,jj] = wxyz.v3\n        end\n    end\n    rxs, rys, rzs\nend\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nxyz = quaternion_belt_trick(timesignal)\nview(visualize(xyz, :surface), window)\n\nrenderloop(window)\n\n\n\n\n\nJuliaset\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nfunction juliadata(max_iterations, imgx, imgy)\n    scalex, scaley = 4.0/imgx, 4.0/imgy\n\n    # initialize our Float32 heightfield\n    heightfield = zeros(Float32, imgx, imgy)\n\n    # do julia set magic!\n    for x=1:imgx, y=1:imgy\n        cy = y * scaley - 2.0\n        cx = x * scalex - 2.0\n        z = Complex(cx, cy)\n        c = Complex(-0.4, 0.6)\n        i = 0\n        for t in 0:max_iterations\n            if norm(z) \n 2.0\n                break\n            end\n            z = z * z + c\n            i = t\n        end\n        heightfield[x,y] = -(i/512f0)\n    end\n    heightfield\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nheightfield = juliadata(256, 700, 700)\n\n# visualize the heightfield as a surface\nvis = visualize(\n    heightfield, :surface,\n    model=rotation\n)\n\n# display it on the window\nview(vis, window)\n\nend\n\nrenderloop(window) # render!\n\n\n\n\n\nMesh\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nfunction mgrid(dim1, dim2)\n    X = [i for i in dim1, j in dim2]\n    Y = [j for i in dim1, j in dim2]\n    return X,Y\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\ndphi, dtheta = pi/200.0f0, pi/200.0f0\n\nphi,theta = mgrid(0f0:dphi:(pi+dphi*1.5f0), 0f0:dtheta:(2f0*pi+dtheta*1.5f0));\nm0 = 4f0; m1 = 3f0; m2 = 2f0; m3 = 3f0; m4 = 6f0; m5 = 2f0; m6 = 6f0; m7 = 4f0;\na = sin(m0*phi).^m1;\nb = cos(m2*phi).^m3;\nc = sin(m4*theta).^m5;\nd = cos(m6*theta).^m7;\nr = a + b + c + d;\nx = r.*sin(phi).*cos(theta);\ny = r.*cos(phi);\nz = r.*sin(phi).*sin(theta);\n\n\nsurface = visualize((x,y,z), :surface, model=rotation)\nview(surface, window)\n\nend\n\nrenderloop(window)\n\n\n\n\n\nSurface\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLAbstraction, Colors, Reactive, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# generate some pretty data\nfunction xy_data(x,y,i, N)\n    x = ((x/N)-0.5f0)*i\n    y = ((y/N)-0.5f0)*i\n    r = sqrt(x*x + y*y)\n    Float32(sin(r)/r)\nend\n\nsurf(i, N) = Float32[xy_data(x, y, i, N) for x=1:N, y=1:N]\n\nt = map(t-\n(t*30f0)+20f0, timesignal)\n\nbb = Signal(AABB{Float32}(Vec3f0(0), Vec3f0(1)))\n\nview(visualize(const_lift(surf, t, 400), :surface, boundingbox=bb))\n\nrenderloop(window)", 
            "title": "Surfaces"
        }, 
        {
            "location": "/examples/surfaces/#dirac-belt", 
            "text": "Your browser does not support the video tag.   using GeometryTypes, Quaternions, GLVisualize, Reactive, GLAbstraction\n\nfunction Quaternions.qrotation{T :Real}(axis::Quaternion{T}, theta::T)\n    ax = Vec{3,T}(axis.v1, axis.v2, axis.v3)\n    qrotation(ax, theta)\nend\n\nfunction Quaternions.qrotation{T :Real}(axis::Quaternion{T}, z::Quaternion{T}, theta::T)\n    q = qrotation(axis, theta)\n    q*z*conj(q)\nend\n\nfunction quaternion_belt_trick(timesignal)\n\n    rad1 = 1f0 # outer circle\n    rad2 = 0.2f0 # inner circle\n\n    center1 = Point2f0(rad1,rad1) # left\n    center2 = Point2f0(rad1+2f0,rad1) # right\n\n    u1234 = Quaternion(0f0,0f0,1f0,0f0) # gets rotated\n    axis  = Quaternion(0f0,0f0,0f0,1f0) # axis of qrotationdd\n    mi  = 80\n    mj  = 10\n    rxs = zeros(Float32, mi+1,mj+1)\n    rys = zeros(Float32, mi+1,mj+1)\n    rzs = zeros(Float32, mi+1,mj+1)\n\n    max_frames = 96\n    dphi = 2*pi/(max_frames-1) # include both ends\n\n    u1234_s = foldp(u1234, timesignal) do v0, _\n        qrotation(axis, v0, Float32(dphi))\n    end\n    xyz = const_lift(plot_belts, rxs, rys, rzs, u1234_s, center1, center2, rad1, rad2)\n    x = const_lift(getindex, xyz, 1)\n    y = const_lift(getindex, xyz, 2)\n    z = const_lift(getindex, xyz, 3)\n    (x,y,z)\nend\n\nfunction plot_belts(rxs, rys, rzs, u1234, center1, center2, rad1, rad2)\n    mi  = 80\n    mj  = 10\n    iis = 1f0:(mi+1f0)\n    rs  = rad1-((rad1-rad2)*(iis-1f0)/mi)\n    for ii=1:(mi+1)\n        jjs   = 1f0:(mj+1f0)\n        xs    = (rad2/mj)*((jjs-1f0)-(mj/2f0))\n        ys    = sqrt(rs[ii]*rs[ii]-xs.*xs)\n        theta = Float32(2*pi*(ii-1)/mi)\n\n        for jj=1:(mj+1)\n            efgh    = Quaternion(0f0, xs[jj], ys[jj], 0f0)\n            wxyz    = qrotation(efgh, u1234, theta)\n            rxs[ii,jj] = center1[1]+wxyz.v1\n            rys[ii,jj] = center1[2]+wxyz.v2\n            rzs[ii,jj] = wxyz.v3\n        end\n    end\n    rxs, rys, rzs\nend\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nxyz = quaternion_belt_trick(timesignal)\nview(visualize(xyz, :surface), window)\n\nrenderloop(window)", 
            "title": "Dirac Belt"
        }, 
        {
            "location": "/examples/surfaces/#juliaset", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nfunction juliadata(max_iterations, imgx, imgy)\n    scalex, scaley = 4.0/imgx, 4.0/imgy\n\n    # initialize our Float32 heightfield\n    heightfield = zeros(Float32, imgx, imgy)\n\n    # do julia set magic!\n    for x=1:imgx, y=1:imgy\n        cy = y * scaley - 2.0\n        cx = x * scalex - 2.0\n        z = Complex(cx, cy)\n        c = Complex(-0.4, 0.6)\n        i = 0\n        for t in 0:max_iterations\n            if norm(z)   2.0\n                break\n            end\n            z = z * z + c\n            i = t\n        end\n        heightfield[x,y] = -(i/512f0)\n    end\n    heightfield\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nheightfield = juliadata(256, 700, 700)\n\n# visualize the heightfield as a surface\nvis = visualize(\n    heightfield, :surface,\n    model=rotation\n)\n\n# display it on the window\nview(vis, window)\n\nend\n\nrenderloop(window) # render!", 
            "title": "Juliaset"
        }, 
        {
            "location": "/examples/surfaces/#mesh", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nfunction mgrid(dim1, dim2)\n    X = [i for i in dim1, j in dim2]\n    Y = [j for i in dim1, j in dim2]\n    return X,Y\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\ndphi, dtheta = pi/200.0f0, pi/200.0f0\n\nphi,theta = mgrid(0f0:dphi:(pi+dphi*1.5f0), 0f0:dtheta:(2f0*pi+dtheta*1.5f0));\nm0 = 4f0; m1 = 3f0; m2 = 2f0; m3 = 3f0; m4 = 6f0; m5 = 2f0; m6 = 6f0; m7 = 4f0;\na = sin(m0*phi).^m1;\nb = cos(m2*phi).^m3;\nc = sin(m4*theta).^m5;\nd = cos(m6*theta).^m7;\nr = a + b + c + d;\nx = r.*sin(phi).*cos(theta);\ny = r.*cos(phi);\nz = r.*sin(phi).*sin(theta);\n\n\nsurface = visualize((x,y,z), :surface, model=rotation)\nview(surface, window)\n\nend\n\nrenderloop(window)", 
            "title": "Mesh"
        }, 
        {
            "location": "/examples/surfaces/#surface", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLAbstraction, Colors, Reactive, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# generate some pretty data\nfunction xy_data(x,y,i, N)\n    x = ((x/N)-0.5f0)*i\n    y = ((y/N)-0.5f0)*i\n    r = sqrt(x*x + y*y)\n    Float32(sin(r)/r)\nend\n\nsurf(i, N) = Float32[xy_data(x, y, i, N) for x=1:N, y=1:N]\n\nt = map(t- (t*30f0)+20f0, timesignal)\n\nbb = Signal(AABB{Float32}(Vec3f0(0), Vec3f0(1)))\n\nview(visualize(const_lift(surf, t, 400), :surface, boundingbox=bb))\n\nrenderloop(window)", 
            "title": "Surface"
        }, 
        {
            "location": "/examples/text/", 
            "text": "Text\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,20))\n\n# GLAbstraction.const_lift is defined as\n# const_lift(F, args...) = Reactive.map(F, map(Signal, args)...)\n# and allows to also use constant arguments without manually wrapping\n# them into signals\n\u03c0_signal = const_lift(*, timesignal, pi)\n\n# Reactive.map takes a signal and transforms it by applying F into a new signal\n# it's similar to Base.map, just over the time dimension (like registering a\n# callback in a more traditional event system)\ns = map(\u03c0_signal) do t\n\nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\n$(t)\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\n$(t) mm\nI can't even...\n\n\nend\n\n# view and visualize it!\nview(visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)) # move this up, since the text starts at 0 and goes down from there\n), window)\n\nrenderloop(window)\n\n\n\n\n\nText Particle\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# Did we mention, that text is just a normal sprite particle system?\n# This means, it supports all the attributes like the other particle systems.\n\n# some text again\ns = \nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\nI can't even...\n\n\n\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    t2\u03c0 = t*pi*2\n    Vec3f0(cos(t2\u03c0),sin(t2\u03c0), 1)\nend\n\n# create some funcy scale change\nscale = map(timesignal) do t\n    circular = sin(t*pi)\n    Vec2f0(1+circular*0.5,1+circular*0.5)\nend\nconst len = length(s)\n\n# per glyph color\ncolor = map(timesignal) do t\n    RGBA{Float32}[RGBA{Float32}(i/len,1, (sin(t)+1.)/2., 1) for i=1:len]\nend\n\n# per glyph stroke color\nstroke_color = RGBA{Float32}[RGBA{Float32}(0,0,0, i/len) for i=1:len]\n\n# view and visualize it!\n# you could also pass positions as a keyword argument or make\n# the scale/rotation per glyph by supplying a Vector of them.\ntextvizz = visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)), # move this up, since the text starts at 0 and goes down from there\n    rotation=rotation,\n    color=color,\n    stroke_color=stroke_color,\n    stroke_width = 1f0,\n    relative_scale=scale\n)\n\nview(textvizz, window)\n\nrenderloop(window)", 
            "title": "Text"
        }, 
        {
            "location": "/examples/text/#text", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,20))\n\n# GLAbstraction.const_lift is defined as\n# const_lift(F, args...) = Reactive.map(F, map(Signal, args)...)\n# and allows to also use constant arguments without manually wrapping\n# them into signals\n\u03c0_signal = const_lift(*, timesignal, pi)\n\n# Reactive.map takes a signal and transforms it by applying F into a new signal\n# it's similar to Base.map, just over the time dimension (like registering a\n# callback in a more traditional event system)\ns = map(\u03c0_signal) do t The quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\n$(t)\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5   a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\n$(t) mm\nI can't even... \nend\n\n# view and visualize it!\nview(visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)) # move this up, since the text starts at 0 and goes down from there\n), window)\n\nrenderloop(window)", 
            "title": "Text"
        }, 
        {
            "location": "/examples/text/#text-particle", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# Did we mention, that text is just a normal sprite particle system?\n# This means, it supports all the attributes like the other particle systems.\n\n# some text again\ns =  The quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5   a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\nI can't even... \n\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    t2\u03c0 = t*pi*2\n    Vec3f0(cos(t2\u03c0),sin(t2\u03c0), 1)\nend\n\n# create some funcy scale change\nscale = map(timesignal) do t\n    circular = sin(t*pi)\n    Vec2f0(1+circular*0.5,1+circular*0.5)\nend\nconst len = length(s)\n\n# per glyph color\ncolor = map(timesignal) do t\n    RGBA{Float32}[RGBA{Float32}(i/len,1, (sin(t)+1.)/2., 1) for i=1:len]\nend\n\n# per glyph stroke color\nstroke_color = RGBA{Float32}[RGBA{Float32}(0,0,0, i/len) for i=1:len]\n\n# view and visualize it!\n# you could also pass positions as a keyword argument or make\n# the scale/rotation per glyph by supplying a Vector of them.\ntextvizz = visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)), # move this up, since the text starts at 0 and goes down from there\n    rotation=rotation,\n    color=color,\n    stroke_color=stroke_color,\n    stroke_width = 1f0,\n    relative_scale=scale\n)\n\nview(textvizz, window)\n\nrenderloop(window)", 
            "title": "Text Particle"
        }, 
        {
            "location": "/examples/volumes/", 
            "text": "Maximum Intensity Projection\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLWindow, GLAbstraction\n\nfunction volume_data(N)\n    volume  = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(volume)\n    min     = minimum(volume)\n    volume  = (volume .- min) ./ (max .- min)\nend\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nvolumedata = volume_data(128)\nusing NIfTI\nvolumedata = niread(assetpath(\nbrain.nii\n)).raw\n\nvolume = visualize(volumedata, :mip)\n\nview(volume, window)\n\n\nrenderloop(window)\n\n\n\n\n\nVolume\n\n\n Your browser does not support the video tag. \n\n\n\nusing GLVisualize, GLWindow\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nfunction volume_data(N)\n    vol     = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(vol)\n    min     = minimum(vol)\n    vol     = (vol .- min) ./ (max .- min)\nend\n\nvol = visualize(volume_data(128), :iso, isovalue=timesignal)\nview(vol, window)\n\n\nrenderloop(window)", 
            "title": "Volumes"
        }, 
        {
            "location": "/examples/volumes/#maximum-intensity-projection", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLWindow, GLAbstraction\n\nfunction volume_data(N)\n    volume  = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(volume)\n    min     = minimum(volume)\n    volume  = (volume .- min) ./ (max .- min)\nend\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nvolumedata = volume_data(128)\nusing NIfTI\nvolumedata = niread(assetpath( brain.nii )).raw\n\nvolume = visualize(volumedata, :mip)\n\nview(volume, window)\n\n\nrenderloop(window)", 
            "title": "Maximum Intensity Projection"
        }, 
        {
            "location": "/examples/volumes/#volume", 
            "text": "Your browser does not support the video tag.   using GLVisualize, GLWindow\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nfunction volume_data(N)\n    vol     = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(vol)\n    min     = minimum(vol)\n    vol     = (vol .- min) ./ (max .- min)\nend\n\nvol = visualize(volume_data(128), :iso, isovalue=timesignal)\nview(vol, window)\n\n\nrenderloop(window)", 
            "title": "Volume"
        }
    ]
}