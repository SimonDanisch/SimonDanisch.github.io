{
    "docs": [
        {
            "location": "/", 
            "text": "THIS IS GLVISUALIZE", 
            "title": "Home"
        }, 
        {
            "location": "/contourf/", 
            "text": "Contourf\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\n# use the performance tips to speed this up\n# (http://docs.julialang.org/en/release-0.4/manual/performance-tips/)\n# the array is 512x512 after all\nconst N = 512\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Intensity{1,Float32}(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Intensity{1,Float32}, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nrenderable = visualize(map(contourdata, timesignal))\n\nview(renderable, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Contourf"
        }, 
        {
            "location": "/interactive/graph_editing/", 
            "text": "Graph Editing\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, Reactive, GLWindow, GLFW\n\nwindow = glscreen()\n\nn = 50\nn_connections = 100\na = rand(Point2f0, n)*1000f0\npoints = visualize((Circle(Point2f0(0), 15f0), a))\n\nconst point_robj = points.children[] # temporary way of getting the render object. Shouldn't stay like this\n # best way to get the gpu object. One could also start by creating a gpu array oneself.\n # this is a bit tricky, since not there are three different types.\n # for points and lines you need a GLBuffer. e.g gpu_position = GLBuffer(rand(Point2f0, 50)*1000f0)\nconst gpu_position = point_robj[:position]\n# now the lines and points share the same gpu object\n# for linesegments, you can pass indices, which needs to be of some 32bit int type\nlines  = visualize(gpu_position, :linesegment, indices=rand(1:n, n_connections))\n\n# current tuple of renderobject id and index into the gpu array\nconst m2id = GLWindow.mouse2id(window)\nisoverpoint = const_lift(is_same_id, m2id, point_robj)\n\n# inputs are a dict, materialize gets the keys out of it (equivalent to mouseposition = window.inputs[:mouseposition])\n@materialize mouse_buttons_pressed, mouseposition = window.inputs\n\n# single left mousekey pressed (while no other mouse key is pressed)\nkey_pressed = const_lift(GLAbstraction.singlepressed, mouse_buttons_pressed, GLFW.MOUSE_BUTTON_LEFT)\n# dragg while key_pressed. Drag only starts if isoverpoint is true\nmousedragg  = GLAbstraction.dragged(mouseposition, key_pressed, isoverpoint)\n\n# use mousedrag and mouseid + index to actually change the gpu array with the positions\npreserve(foldp((value(m2id)..., Point2f0(0)), mousedragg) do v0, dragg\n    if dragg == Vec2f0(0) # if drag just started. Not the best way, maybe dragged should return a tuple of (draggvalue, started)\n        id, index = value(m2id)\n        if id==point_robj.id \n length(gpu_position) \n= index\n            p0 = gpu_position[index]\n        else\n            p0 = v0[3]\n        end\n    else\n        id, index, p0 = v0\n        if id==point_robj.id \n length(gpu_position) \n= index\n            gpu_position[index] = Point2f0(p0) + Point2f0(dragg)\n        end\n\n    end\n    return id, index, p0\nend)\n# view it!\nview(lines, window, camera=:fixed_pixel)\nview(points, window, camera=:fixed_pixel)\n\n renderloop(window)", 
            "title": "Graph editing"
        }, 
        {
            "location": "/interactive/image_processing/", 
            "text": "Image Processing\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing Images, Colors, GeometryTypes\nusing Reactive, FileIO, GLVisualize\nusing GLAbstraction, GeometryTypes, GLWindow\n\nwindow = glscreen()\n\n# loadasset loads data from the GLVisualize asset folder and is defined as\n# FileIO.load(assetpath(name))\ndoge = loadasset(\ndoge.png\n)\n# Convert to RGBA{Float32}. Float for filtering and 32 because it fits the GPU better\nimg = map(RGBA{Float32}, doge)\n# create a slider that goes from 1-20 in 0.1 steps\nslider_s, slider = vizzedit(1f0:0.1f0:20f0, window)\n\n# performant conversion to RGBAU8, implemted with a functor\n# in 0.5 anonymous functions offer the same speed, so this wouldn't be needed\nimmutable ClampRGBAU8 end\ncall(::ClampRGBAU8, x) = RGBA{U8}(clamp(comp1(x), 0,1), clamp(comp2(x), 0,1), clamp(comp3(x), 0,1), clamp(alpha(x), 0,1))\n\n\n\nApplies a gaussian filter to `img` and converts it to RGBA{U8}\n\n\nfunction myfilter(img, sigma)\n    img = Images.imfilter_gaussian(img, [sigma, sigma])\n    map(ClampRGBAU8(), img).data\nend\n\n\nstartvalue = myfilter(img, value(slider_s))\n# Use Reactive.async_map, to filter the image without blocking the main process\ntask, imgsig = async_map(myfilter, startvalue, Signal(img), slider_s)\n# visualize the image signal\nimage_renderable = visualize(imgsig, model=translationmatrix(Vec3f0(50,100,0)))\nview(image_renderable)\n\nvec2i(a,b,x...) = Vec{2,Int}(round(Int, a), round(Int, b))\nvec2i(vec::Vec) = vec2i(vec...)\n\n\ncreates a rectangle around `robj`\n\n\nfunction screen(robj)\n    bb = value(boundingbox(robj))\n    m  = vec2i(minimum(bb))\n    area = SimpleRectangle{Float32}(0,0, ((vec2i(maximum(bb))-m)+30)...)\n\n    view(visualize((area, [Point2f0(0)]),\n        color=RGBA{Float32}(0,0,0,0), stroke_color=RGBA{Float32}(0,0,0,0.7),\n        stroke_width=2f0),\n        camera=:fixed_pixel\n    )\n    robj.children[][:model] = translationmatrix(Vec3f0(15,15,0)-minimum(bb))\n    view(robj, camera=:fixed_pixel)\nend\nscreen(slider)\n\nrenderloop(window)", 
            "title": "Image processing"
        }, 
        {
            "location": "/interactive/mario_game/", 
            "text": "Mario Game\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, ImageMagick\nusing FileIO, ColorTypes, Reactive\n\n window = glscreen()\n\ntype Mario{T}\n    x           ::T\n    y           ::T\n    vx          ::T\n    vy          ::T\n    direction   ::Symbol\nend\n\n\n\ngravity(dt, mario) = (mario.vy = (mario.y \n 0.0 ? mario.vy - (dt/4.0) : 0.0); mario)\n\nfunction physics(dt, mario)\n    mario.x = mario.x + dt * mario.vx\n    mario.y = max(0.0, mario.y + dt * mario.vy)\n    mario\nend\n\nfunction walk(keys, mario)\n    mario.vx = keys[1]\n    mario.direction = keys[1] \n 0.0 ? :left : keys[1] \n 0.0 ? :right : mario.direction\n    mario\nend\n\nfunction jump(keys, mario)\n    if keys[2] \n 0.0 \n mario.vy == 0.0\n        mario.vy = 6.0\n    end\n    mario\nend\n\nfunction update(dt, keys, mario)\n    mario = gravity(dt, mario)\n    mario = jump(keys,  mario)\n    mario = walk(keys,  mario)\n    mario = physics(dt, mario)\n    mario\nend\n\n\n\nmario2model(mario) = translationmatrix(Vec3f0(mario.x, mario.y, 0f0))*scalematrix(Vec3f0(5f0))\n\nconst mario_images = Dict()\n\n\nfunction play(x::Vector)\n    const_lift(getindex, x, loop(1:length(x)))\nend\n\nfunction read_sequence(path)\n    if isdir(path)\n        return map(load, sort(map(x-\njoinpath(path, x), readdir(path))))\n    else\n        return fill(load(path), 1)\n    end\nend\n\nfor verb in [\njump\n, \nwalk\n, \nstand\n], dir in [\nleft\n, \nright\n]\n    pic = dir\n    if verb != \nwalk\n # not a sequemce\n        pic *= \n.png\n\n    end\n    path = assetpath(\nmario\n, verb, pic)\n    sequence = read_sequence(path)\n    gif = map(img-\nmap(RGBA{U8}, img), sequence)\n    mario_images[verb*dir] = play(gif)\nend\nfunction mario2image(mario, images=mario_images)\n    verb = mario.y \n 0.0 ? \njump\n : mario.vx != 0.0 ? \nwalk\n : \nstand\n\n    mario_images[verb*string(mario.direction)].value # is a signal of pictures itself (animation), so .value samples the current image\nend\nfunction arrows2vec(direction)\n    direction == :up    \n return Vec2f0( 0.0,  1.0)\n    direction == :down  \n return Vec2f0( 0.0, -1.0)\n    direction == :right \n return Vec2f0( 3.0,  0.0)\n    direction == :left  \n return Vec2f0(-3.0,  0.0)\n    Vec2f0(0.0)\nend\n\n# Put everything together\narrows          = sampleon(bounce(1:10), window.inputs[:arrow_navigation])\nkeys            = const_lift(arrows2vec, arrows)\nmario_signal    = const_lift(update, 8.0, keys, Mario(0.0, 0.0, 0.0, 0.0, :right))\nimage_stream    = const_lift(mario2image, mario_signal)\nmodelmatrix     = const_lift(mario2model, mario_signal)\n\nmario = visualize(image_stream, model=modelmatrix)\n\nview(mario, window, camera=:fixed_pixel)\n\n renderloop(window)", 
            "title": "Mario game"
        }, 
        {
            "location": "/introduction/rotate_robj/", 
            "text": "Rotate Robj\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction\nusing FileIO, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nmesh            = loadasset(\ncat.obj\n)\nrotation_angle  = const_lift(*, timesignal, 2f0*pi)\nstart_rotation  = Signal(rotationmatrix_x(deg2rad(90f0))) # the cat needs some rotation on the x axis to stand straight\nrotation        = map(rotationmatrix_y, rotation_angle)\nfinal_rotation  = map(*, start_rotation, rotation)\nrobj            = visualize(mesh, model=final_rotation)\n\n\nview(robj, window)\n\nrenderloop(window)", 
            "title": "Rotate robj"
        }, 
        {
            "location": "/lines/contourlines/", 
            "text": "Contourlines\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing Contour, GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nxrange = -5f0:0.02f0:5f0\nyrange = -5f0:0.02f0:5f0\n\nz = Float32[sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x) for x in xrange, y in yrange]\nmini = minimum(z)\nmaxi = maximum(z)\ncolor_ramp = map(x-\nRGBA{Float32}(x, 1.0), colormap(\nBlues\n))\nheight2color(val, mini, maxi) = color_ramp[floor(Int, (((val-mini)/(maxi-mini))*(length(color_ramp)-1)))+1]\n\nfor h in mini:0.2f0:maxi\n    c = contour(xrange, yrange, z, h)\n    for elem in c.lines\n        points = map(elem.vertices) do p\n            Point3f0(p, h)\n        end\n        line_renderable = visualize(\n            points, :lines,\n            color=height2color(h, mini, maxi),\n            model=rotation\n        )\n        view(line_renderable, window, camera=:perspective)\n    end\nend\n\n renderloop(window)", 
            "title": "Contourlines"
        }, 
        {
            "location": "/lines/lines3D/", 
            "text": "Lines3D\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLAbstraction, Colors, GeometryTypes, GLVisualize, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n\nn = 400 # The number of points per line\nnloops = 20 # The number of loops\n# The scalar parameter for each line\nTL = linspace(-2f0 * pi, 2f0 * pi, n)\n# We create a list of positions and connections, each describing a line.\n# We will collapse them in one array before plotting.\nxyz    = Point3f0[]\ncolors = RGBA{Float32}[]\n\n# creates some distinguishable colors from which we can sample for each line\nbase_colors1 = distinguishable_colors(nloops, RGB{Float64}(1,0,0))\n# Create each line one after the other in a loop\nfor i=1:nloops\n    append!(xyz, [Point3f0(sin(t), cos((2 + .02 * i) * t), cos((3 + .03 * i) * t)) for t in TL])\n    unique_colors = base_colors1[i]\n    hsv = HSV(unique_colors)\n    color_palette = map(x-\nRGBA{Float32}(x, 1.0), sequential_palette(hsv.h, n, s=hsv.s))\n    append!(colors, color_palette)\nend\n\n# map comes from Reactive.jl and allows you to map any Signal to another.\n# In this case we create a rotation matrix from the timesignal signal.\n\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nlines3d = visualize(xyz, :lines, color=colors, model=rotation)\n\nview(lines3d, window, camera=:perspective)\n\n renderloop(window)", 
            "title": "lines3D"
        }, 
        {
            "location": "/lines/linesegments3d/", 
            "text": "Linesegments3d\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors\nusing Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlarge_sphere = HyperSphere(Point3f0(0), 1f0)\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\npositions = decompose(Point3f0, large_sphere)\nindices = rand(range(Cuint(0), Cuint(length(positions))), 1000)\n\ncolor = map(large_sphere-\nRGBA{Float32}(large_sphere, 0.9f0), colormap(\nBlues\n, length(positions)))\ncolor2 = map(large_sphere-\nRGBA{Float32}(large_sphere, 1f0), colormap(\nBlues\n, length(positions)))\n\nlines = visualize(\n    positions, :linesegment, thickness=0.5f0,\n    color=color, indices=indices, model=rotation\n)\nspheres = visualize(\n    (Sphere{Float32}(Point3f0(0.0), 1f0), positions),\n    color=color2, scale=Vec3f0(0.05), model=rotation\n)\nview(lines, window, camera=:perspective)\nview(spheres, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Linesegments3d"
        }, 
        {
            "location": "/meshes/meshes/", 
            "text": "Meshes\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\n\nmsh = GLNormalMesh(loadasset(\ncat.obj\n))\n\nview(visualize(msh), window)\n\nrenderloop(window)", 
            "title": "Meshes"
        }, 
        {
            "location": "/not_working/juliaset/", 
            "text": "Juliaset\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nmeshgrid(v::AbstractVector) = meshgrid(v, v)\n\nfunction meshgrid{T}(vx::AbstractVector{T}, vy::AbstractVector{T})\n    m, n = length(vy), length(vx)\n    vx = reshape(vx, 1, n)\n    vy = reshape(vy, m, 1)\n    (repmat(vx, m, 1), repmat(vy, 1, n))\nend\n\nfunction meshgrid{T}(vx::AbstractVector{T}, vy::AbstractVector{T},\n                     vz::AbstractVector{T})\n    m, n, o = length(vy), length(vx), length(vz)\n    vx = reshape(vx, 1, n, 1)\n    vy = reshape(vy, m, 1, 1)\n    vz = reshape(vz, 1, 1, o)\n    om = ones(Int, m)\n    on = ones(Int, n)\n    oo = ones(Int, o)\n    (vx[om, :, oo], vy[:, on, oo], vz[om, on, :])\nend\n\n# Calculate the Julia set on a grid\nx,y = meshgrid(-1.5f0:0.5f0:500f0, -1f0:1f0:500f0)\nx *= 1im\ny *= 1im\nz = x + 1im * y\n\nconst julia = zeros(Float32, size(z))\n\nfor i=1:50\n    for i in eachindex(julia)\n        z[i] = (z[i]^2) - 0.70176 - 0.3842im\n        x = (z[i] * (real(conj(z[i])) \n 4))\n        julia[i] += real(1f0 / (2f0 + i) * x)\n    end\nend\nmaxval = maximum(julia)\nmap!(julia ) do val \n    val / maxval\nend\nusing GLVisualize\nw =glscreen()\n# Display it\nview(visualize(julia))\n\nrenderloop(w)", 
            "title": "Juliaset"
        }, 
        {
            "location": "/particles/bars/", 
            "text": "Bars\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, Colors, GeometryTypes, GLAbstraction, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\nconst N = 87\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Float32(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Float32, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nheightfield = map(contourdata, timesignal)\nmini = Vec3f0(first(range), first(range), minimum(value(heightfield)))\nmaxi = Vec3f0(last(range), last(range), maximum(value(heightfield)))\nbars = visualize(\n    heightfield,\n    scale_x = 0.07,\n    scale_y = 0.07,\n    color_map=map(RGBA{U8}, colormap(\nBlues\n)),\n    color_norm=Vec2f0(0,1),\n    ranges=(range, range),\n    boundingbox=Signal(AABB{Float32}(mini, maxi))\n)\nview(bars, window)\n\nrenderloop(window)", 
            "title": "Bars"
        }, 
        {
            "location": "/particles/cubicles/", 
            "text": "Cubicles\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\ncube = HyperRectangle(Vec3f0(0), Vec3f0(0.05))\nn = 20\nconst wx,wy,wz = widths(cube)\n\nmesh = GLNormalMesh(cube)\n\ntimepi = const_lift(*, timesignal, 2f0*pi)\nfunction position(t, x, y)\n    pos = Point3f0(x*(sqrt(wx^2+wy^2)), -y*wy, y*wz)\n    dir = Point3f0(0, wy, wz)\n    pos = pos + sin(t)*dir\nend\nposition_signal = map(timepi) do t\n    vec(Point3f0[position(t,x,y) for x=1:n, y=1:n])\nend\n\nrotation = map(timepi) do t\n    vec(Vec3f0[Vec3f0(cos(t+(x/7)),sin(t+(y/7)), 1) for x=1:20, y=1:20])\nend\n\ncubes = visualize(\n    (mesh, position_signal),\n    rotation=rotation,\n    color_map=GLVisualize.default(Vector{RGBA}),\n    color_norm=Vec2f0(1,1.8)\n    # intensity that will define the color sampled from color_map will fallback\n    # to the length of the rotation vector.\n    # you could also supply it via intensity = Vector{Float32}\n)\n\n# we create our own camera to better adjust to what we want to see.\ncamera = PerspectiveCamera(\n    Signal(Vec3f0(0)), # theta (rotate by x around cam xyz axis)\n    Signal(Vec3f0(0)), # translation (translate by translation in the direction of the cam xyz axis)\n    Signal(Vec3f0(wx*n+4wx,wy*n,wz*n)/2), # lookat. We want to look at the middle of the cubes\n    Signal(Vec3f0(((wx*n+4wx)/2),1.2*wy*n,(wz*n)/2)), # camera position. We want to be on the same height, but further away in y\n    Signal(Vec3f0(0,0,1)), #upvector\n    window.area, # window area\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0), # Max distance (clip distance)\n    Signal(GLAbstraction.ORTHOGRAPHIC)\n)\nview(cubes, window, camera=camera)\n\n\nrenderloop(window)", 
            "title": "Cubicles"
        }, 
        {
            "location": "/particles/flow3D/", 
            "text": "Flow3D\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 7\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec3f0[(sin(x/t), cos(y/(t/2f0)), sqrt(t+z^2)) for x=1:N, y=1:N, z=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow)\nview(vis, window)\n\n renderloop(window)", 
            "title": "flow3D"
        }, 
        {
            "location": "/particles/particles/", 
            "text": "Particles\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0, 360))\n\ncat    = GLNormalMesh(loadasset(\ncat.obj\n))\nsphere = GLNormalMesh(Sphere{Float32}(Vec3f0(0), 1f0), 12)\n\nfunction scale_gen(v0, nv)\n    l = length(v0)\n    @inbounds for i=1:l\n        v0[i] = Vec3f0(1,1,sin((nv*l)/i))/2\n    end\n    v0\nend\nfunction color_gen(v0, t)\n    l = length(v0)\n    @inbounds for x=1:l\n        v0[x] = RGBA{U8}(x/l,(cos(t)+1)/2,(sin(x/l/3)+1)/2.,1.)\n    end\n    v0\nend\n\nt            = const_lift(x-\nx+0.1, timesignal)\nps           = sphere.vertices\nscale_start  = Vec3f0[Vec3f0(1,1,rand()) for i=1:length(ps)]\nscale        = foldp(scale_gen, scale_start, t)\ncolorstart   = color_gen(zeros(RGBA{U8}, length(ps)), value(t))\ncolor        = foldp(color_gen, colorstart, t)\nrotation     = -sphere.normals\n\ncats = visualize((cat, ps), scale=scale, color=color, rotation=rotation)\n\nview(cats, window)\n\nrenderloop(window)", 
            "title": "Particles"
        }, 
        {
            "location": "/particles/sinfun/", 
            "text": "Sinfun\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\n\nt = const_lift(*, timesignal, 2pi)\nn = 50\nconst yrange = linspace(0.03, 0.3, n)\ntrange = linspace(0, 10pi, 200)\n\nfunction gen_points(timesignal, y)\n    x = sin(timesignal+(y*60*pi*y)+y)*y*5\n    z = cos((timesignal+pi)+(y*60*pi*y)+y)*y*5\n    Point3f0(x,y*60f0,z)\nend\nfunction gen_points(timesignal)\n    Point3f0[gen_points(timesignal, y) for y in yrange]\nend\n\npositions = map(gen_points, timesignal)\nscale     = map(Vec3f0, yrange)\nprimitive = centered(Sphere)\npoints    = visualize((primitive, positions), scale=scale)\n\nview(points, window)\n\nrenderloop(window)", 
            "title": "Sinfun"
        }, 
        {
            "location": "/particles/sprites/arrows/", 
            "text": "Arrows\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 20\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec2f0[(sin(x/t), cos(y/(t/2f0))) for x=1:N, y=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow, ranges=(50:800,50:500))\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)", 
            "title": "Arrows"
        }, 
        {
            "location": "/particles/sprites/billboard/", 
            "text": "Billboard\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, ModernGL, FileIO, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlet\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nconst b = Point3f0[(rand(Point3f0)*2)-1 for i=1:64]\n\nsprites = visualize(\n    (SimpleRectangle(0f0,0f0,0.5f0, 0.5f0), b),\n    billboard=true, image=loadasset(\ndoge.png\n),\n    model=rotation\n)\n\nview(sprites, window, camera=:perspective)\nend\n\nrenderloop(window)", 
            "title": "Billboard"
        }, 
        {
            "location": "/particles/sprites/bouncy/", 
            "text": "Bouncy\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n window = glscreen()\n timesignal = bounce(linspace(0,1,50))\nn = 30\nconst border = 50f0\nfunction bounce_particles(pos_velo, _)\n    positions, velocity = pos_velo\n    dt = 0.1f0\n    @inbounds for i=1:length(positions)\n        pos,velo = positions[i], velocity[i]\n        positions[i] = Point2f0(pos[1], pos[2] + velo*dt)\n        if pos[2] \n= border\n            velocity[i] = abs(velo)\n        else\n            velocity[i] = velo - 9.8*dt\n        end\n    end\n    positions, velocity\nend\nstart_position = (rand(Point2f0, n)*700f0) + border\nposition_velocity = foldp(bounce_particles,\n    (start_position, zeros(Float32, n)),\n    timesignal\n)\ncircle = HyperSphere(Point2f0(0), 40f0)\nvis = visualize((circle, map(first, position_velocity)),\n    image=loadasset(\ndoge.png\n),\n    stroke_width=3f0,\n    stroke_color=RGBA{Float32}(0.91,0.91,0.91,1)\n)\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)", 
            "title": "Bouncy"
        }, 
        {
            "location": "/particles/sprites/image_texture_atlas/", 
            "text": "Image Texture Atlas\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\n\n# this is just one big texture\ntexture_atlas = loadasset(\ndoge.png\n)\nw, h = size(texture_atlas)\nconst n = 40\nxrange = linspace(0, w, n)\nyrange = linspace(0, h, n)\nscale  = Vec2f0(step(xrange), step(yrange))\n\n# position in a grid\npositions = map(timesignal) do t\n    vec(Point2f0[(x+(sin(t*2*pi)*400),y+(sin(0+y*t*0.01)*200)+(cos(t*2*pi)*200)) for x=xrange, y=yrange])\nend\n\n# uv coordinates are normalized coordinates into the texture_atlas\n# they need the start point and the width of each rectangle (sprites are rectangles)\n# so you will not actually index with the circle primitive, but rather with\n# with the quad of the particle (the rest of the quad is transparent)\n# note, that for uv coordinates, the origin is on the top left corner\nuv_offset_width = vec(Vec4f0[(x,y,x+(1/n),y+(1/n)) for x=linspace(0, 1, n), y=linspace(1, 0, n)])\n\n# when position and scale are defined, We can leave the middle and radius of\n# Circle undefined, so just passing the type.\ndistfield = visualize((Circle, positions),\n    scale=scale,\n    stroke_width=1f0,\n    uv_offset_width=uv_offset_width,\n    stroke_color = RGBA{Float32}(0.9,0.9,0.9,1.0),\n    image=texture_atlas\n)\nview(distfield, window)\n\n\n renderloop(window)", 
            "title": "Image texture atlas"
        }, 
        {
            "location": "/particles/sprites/moving_bars/", 
            "text": "Moving Bars\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\nwindow = glscreen()\ntimesignal = bounce(0f0:0.1:1f0)\n\nprimitive = SimpleRectangle(0f0,-0.5f0,1f0,1f0)\npositions = rand(10f0:0.01f0:200f0, 10)\n\nfunction interpolate(a, positions, t)\n    [ae+((be-ae)*t) for (ae, be) in zip(a,positions)]\nend\nt = const_lift(*, timesignal, 10f0)\ninterpolated = foldp((positions,positions,positions), t) do v0_v1_ip, td\n    v0,v1,ip = v0_v1_ip\n    pol = td%1\n    if isapprox(pol, 0.0)\n        v0 = v1\n        v1 = map(x-\n rand(linspace(-50f0, 60f0, 100)), v0)\n    end\n    v0, v1, interpolate(v0, v1, pol)\nend\nb_sig = map(last, interpolated)\nbars = visualize(\n    (RECTANGLE, b_sig),\n    intensity=b_sig,\n    ranges=linspace(0,600, 10),\n    color_norm=Vec2f0(-40,200),\n    color_map=GLVisualize.default(Vector{RGBA})\n)\nview(bars, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Moving bars"
        }, 
        {
            "location": "/particles/sprites/moving_circles/", 
            "text": "Moving Circles\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nt          = const_lift(*, timesignal, 10f0)\nradius     = 200f0\nw,h        = widths(window)\nmiddle     = Point2f0(w/2, h/2)\ncircle_pos = Point2f0[(Point2f0(sin(i), cos(i))*radius)+middle for i=linspace(0, 2pi, 20)]\nrotation   = Vec2f0[normalize(Vec2f0(middle)-Vec2f0(p)) for p in circle_pos]\nscales     = map(t) do t\n    Vec2f0[Vec2f0(30, ((sin(i+t)+1)/2)*60) for i=linspace(0, 2pi, 20)]\nend\n\ncircles = visualize(\n    (CIRCLE, circle_pos),\n    rotation=rotation, scale=scales,\n)\n\nview(circles, window)\n\nrenderloop(window)", 
            "title": "Moving circles"
        }, 
        {
            "location": "/particles/text/text/", 
            "text": "Text\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,20))\n\n# GLAbstraction.const_lift is defined as\n# const_lift(F, args...) = Reactive.map(F, map(Signal, args)...)\n# and allows to also use constant arguments without manually wrapping\n# them into signals\n\u03c0_signal = const_lift(*, timesignal, pi)\n\n# Reactive.map takes a signal and transforms it by applying F into a new signal\n# it's similar to Base.map, just over the time dimension (like registering a\n# callback in a more traditional event system)\ns = map(\u03c0_signal) do t\n\nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\n$(t)\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\n$(t) mm\nI can't even...\n\n\nend\n\n# view and visualize it!\nview(visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)) # move this up, since the text starts at 0 and goes down from there\n), window)\n\nrenderloop(window)", 
            "title": "Text"
        }, 
        {
            "location": "/particles/text/text_particle/", 
            "text": "Text Particle\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# Did we mention, that text is just a normal sprite particle system?\n# This means, it supports all the attributes like the other particle systems.\n\n# some text again\ns = \nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\nI can't even...\n\n\n\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    t2\u03c0 = t*pi*2\n    Vec3f0(cos(t2\u03c0),sin(t2\u03c0), 1)\nend\n\n# create some funcy scale change\nscale = map(timesignal) do t\n    circular = sin(t*pi)\n    Vec2f0(1+circular*0.5,1+circular*0.5)\nend\nconst len = length(s)\n\n# per glyph color\ncolor = map(timesignal) do t\n    RGBA{Float32}[RGBA{Float32}(i/len,1, (sin(t)+1.)/2., 1) for i=1:len]\nend\n\n# per glyph stroke color\nstroke_color = RGBA{Float32}[RGBA{Float32}(0,0,0, i/len) for i=1:len]\n\n# view and visualize it!\n# you could also pass positions as a keyword argument or make\n# the scale/rotation per glyph by supplying a Vector of them.\ntextvizz = visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)), # move this up, since the text starts at 0 and goes down from there\n    rotation=rotation,\n    color=color,\n    stroke_color=stroke_color,\n    stroke_width = 1f0,\n    relative_scale=scale\n)\n\nview(textvizz, window)\n\nrenderloop(window)", 
            "title": "Text particle"
        }, 
        {
            "location": "/surfaces/juliaset/", 
            "text": "Juliaset\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction\n\n window = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction juliadata(max_iterations, imgx, imgy)\n    scalex, scaley = 4.0/imgx, 4.0/imgy\n\n    # initialize our Float32 heightfield\n    heightfield = zeros(Float32, imgx, imgy)\n\n    # do julia set magic!\n    for x=1:imgx, y=1:imgy\n        cy = y * scaley - 2.0\n        cx = x * scalex - 2.0\n        z = Complex(cx, cy)\n        c = Complex(-0.4, 0.6)\n        i = 0\n        for t in 0:max_iterations\n            if norm(z) \n 2.0\n                break\n            end\n            z = z * z + c\n            i = t\n        end\n        heightfield[x,y] = -(i/512f0)\n    end\n    heightfield\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nheightfield = juliadata(256, 700, 700)\n\n# visualize the heightfield as a surface\nvis = visualize(\n    heightfield, :surface,\n    model=rotation\n)\n\n# display it on the window\nview(vis, window)\n\nend\n\n renderloop(window) # render!", 
            "title": "Juliaset"
        }, 
        {
            "location": "/surfaces/mesh/", 
            "text": "Mesh\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction, GeometryTypes, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction mgrid(dim1, dim2)\n    X = [i for i in dim1, j in dim2]\n    Y = [j for i in dim1, j in dim2]\n    return X,Y\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\ndphi, dtheta = pi/200.0f0, pi/200.0f0\n\nphi,theta = mgrid(0f0:dphi:(pi+dphi*1.5f0), 0f0:dtheta:(2f0*pi+dtheta*1.5f0));\nm0 = 4f0; m1 = 3f0; m2 = 2f0; m3 = 3f0; m4 = 6f0; m5 = 2f0; m6 = 6f0; m7 = 4f0;\na = sin(m0*phi).^m1;\nb = cos(m2*phi).^m3;\nc = sin(m4*theta).^m5;\nd = cos(m6*theta).^m7;\nr = a + b + c + d;\nx = r.*sin(phi).*cos(theta);\ny = r.*cos(phi);\nz = r.*sin(phi).*sin(theta);\n\n\nsurface = visualize((x,y,z), :surface, model=rotation)\nview(surface, window)\n\nend\n\nrenderloop(window)", 
            "title": "Mesh"
        }, 
        {
            "location": "/surfaces/surface/", 
            "text": "Surface\n\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction, Colors, Reactive, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# generate some pretty data\nfunction xy_data(x,y,i, N)\n    x = ((x/N)-0.5f0)*i\n    y = ((y/N)-0.5f0)*i\n    r = sqrt(x*x + y*y)\n    Float32(sin(r)/r)\nend\n\nsurf(i, N) = Float32[xy_data(x, y, i, N) for x=1:N, y=1:N]\n\nt = map(t-\n(t*30f0)+20f0, timesignal)\n\nbb = Signal(AABB{Float32}(Vec3f0(0), Vec3f0(1)))\n\nview(visualize(const_lift(surf, t, 400), :surface, boundingbox=bb))\n\nrenderloop(window)", 
            "title": "Surface"
        }
    ]
}