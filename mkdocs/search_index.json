{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Documentation of GLVisualize", 
            "title": "Introduction"
        }, 
        {
            "location": "/examples/introduction/", 
            "text": "Rotate Robj\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction\nusing FileIO, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nmesh            = loadasset(\ncat.obj\n)\nrotation_angle  = const_lift(*, timesignal, 2f0*pi)\nstart_rotation  = Signal(rotationmatrix_x(deg2rad(90f0))) # the cat needs some rotation on the x axis to stand straight\nrotation        = map(rotationmatrix_y, rotation_angle)\nfinal_rotation  = map(*, start_rotation, rotation)\nrobj            = visualize(mesh, model=final_rotation)\n\n\nview(robj, window)\n\nrenderloop(window)", 
            "title": "Introduction"
        }, 
        {
            "location": "/examples/introduction/#rotate-robj", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GLAbstraction\nusing FileIO, GeometryTypes, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\nmesh            = loadasset( cat.obj )\nrotation_angle  = const_lift(*, timesignal, 2f0*pi)\nstart_rotation  = Signal(rotationmatrix_x(deg2rad(90f0))) # the cat needs some rotation on the x axis to stand straight\nrotation        = map(rotationmatrix_y, rotation_angle)\nfinal_rotation  = map(*, start_rotation, rotation)\nrobj            = visualize(mesh, model=final_rotation)\n\n\nview(robj, window)\n\nrenderloop(window)", 
            "title": "Rotate Robj"
        }, 
        {
            "location": "/examples/particles/", 
            "text": "Bars\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, Colors, GeometryTypes, GLAbstraction, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\nconst N = 87\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Float32(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Float32, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nheightfield = map(contourdata, timesignal)\nmini = Vec3f0(first(range), first(range), minimum(value(heightfield)))\nmaxi = Vec3f0(last(range), last(range), maximum(value(heightfield)))\nbars = visualize(\n    heightfield,\n    scale_x = 0.07,\n    scale_y = 0.07,\n    color_map=map(RGBA{U8}, colormap(\nBlues\n)),\n    color_norm=Vec2f0(0,1),\n    ranges=(range, range),\n    boundingbox=Signal(AABB{Float32}(mini, maxi))\n)\nview(bars, window)\n\nrenderloop(window)\n\n\n\n\n\nCubicles\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\ncube = HyperRectangle(Vec3f0(0), Vec3f0(0.05))\nn = 20\nconst wx,wy,wz = widths(cube)\n\nmesh = GLNormalMesh(cube)\n\ntimepi = const_lift(*, timesignal, 2f0*pi)\nfunction position(t, x, y)\n    pos = Point3f0(x*(sqrt(wx^2+wy^2)), -y*wy, y*wz)\n    dir = Point3f0(0, wy, wz)\n    pos = pos + sin(t)*dir\nend\nposition_signal = map(timepi) do t\n    vec(Point3f0[position(t,x,y) for x=1:n, y=1:n])\nend\n\nrotation = map(timepi) do t\n    vec(Vec3f0[Vec3f0(cos(t+(x/7)),sin(t+(y/7)), 1) for x=1:20, y=1:20])\nend\n\ncubes = visualize(\n    (mesh, position_signal),\n    rotation=rotation,\n    color_map=GLVisualize.default(Vector{RGBA}),\n    color_norm=Vec2f0(1,1.8)\n    # intensity that will define the color sampled from color_map will fallback\n    # to the length of the rotation vector.\n    # you could also supply it via intensity = Vector{Float32}\n)\n\n# we create our own camera to better adjust to what we want to see.\ncamera = PerspectiveCamera(\n    Signal(Vec3f0(0)), # theta (rotate by x around cam xyz axis)\n    Signal(Vec3f0(0)), # translation (translate by translation in the direction of the cam xyz axis)\n    Signal(Vec3f0(wx*n+4wx,wy*n,wz*n)/2), # lookat. We want to look at the middle of the cubes\n    Signal(Vec3f0(((wx*n+4wx)/2),1.2*wy*n,(wz*n)/2)), # camera position. We want to be on the same height, but further away in y\n    Signal(Vec3f0(0,0,1)), #upvector\n    window.area, # window area\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0), # Max distance (clip distance)\n    Signal(GLAbstraction.ORTHOGRAPHIC)\n)\nview(cubes, window, camera=camera)\n\n\nrenderloop(window)\n\n\n\n\n\nFlow3D\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 7\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec3f0[(sin(x/t), cos(y/(t/2f0)), sqrt(t+z^2)) for x=1:N, y=1:N, z=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow)\nview(vis, window)\n\n renderloop(window)\n\n\n\n\n\nParticles\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0, 360))\n\ncat    = GLNormalMesh(loadasset(\ncat.obj\n))\nsphere = GLNormalMesh(Sphere{Float32}(Vec3f0(0), 1f0), 12)\n\nfunction scale_gen(v0, nv)\n    l = length(v0)\n    @inbounds for i=1:l\n        v0[i] = Vec3f0(1,1,sin((nv*l)/i))/2\n    end\n    v0\nend\nfunction color_gen(v0, t)\n    l = length(v0)\n    @inbounds for x=1:l\n        v0[x] = RGBA{U8}(x/l,(cos(t)+1)/2,(sin(x/l/3)+1)/2.,1.)\n    end\n    v0\nend\n\nt            = const_lift(x-\nx+0.1, timesignal)\nps           = sphere.vertices\nscale_start  = Vec3f0[Vec3f0(1,1,rand()) for i=1:length(ps)]\nscale        = foldp(scale_gen, scale_start, t)\ncolorstart   = color_gen(zeros(RGBA{U8}, length(ps)), value(t))\ncolor        = foldp(color_gen, colorstart, t)\nrotation     = -sphere.normals\n\ncats = visualize((cat, ps), scale=scale, color=color, rotation=rotation)\n\nview(cats, window)\n\nrenderloop(window)\n\n\n\n\n\nSinfun\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\n\nt = const_lift(*, timesignal, 2pi)\nn = 50\nconst yrange = linspace(0.03, 0.3, n)\ntrange = linspace(0, 10pi, 200)\n\nfunction gen_points(timesignal, y)\n    x = sin(timesignal+(y*60*pi*y)+y)*y*5\n    z = cos((timesignal+pi)+(y*60*pi*y)+y)*y*5\n    Point3f0(x,y*60f0,z)\nend\nfunction gen_points(timesignal)\n    Point3f0[gen_points(timesignal, y) for y in yrange]\nend\n\npositions = map(gen_points, timesignal)\nscale     = map(Vec3f0, yrange)\nprimitive = centered(Sphere)\npoints    = visualize((primitive, positions), scale=scale)\n\nview(points, window)\n\nrenderloop(window)", 
            "title": "Particles"
        }, 
        {
            "location": "/examples/particles/#bars", 
            "text": "Your browser does not support the video tag.  using GLVisualize, Colors, GeometryTypes, GLAbstraction, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\nconst N = 87\nconst range = linspace(-5f0, 5f0, N)\n\nfunction contour_inner(i, x, y)\n    Float32(sin(1.3*x*i)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x))\nend\nconst data = zeros(Float32, N, N)\n\nfunction contourdata(t)\n    for i=1:size(data, 1)\n        @simd for j=1:size(data, 2)\n            @inbounds data[i,j] = contour_inner(t, range[i], range[j])\n        end\n    end\n    data\nend\n\nheightfield = map(contourdata, timesignal)\nmini = Vec3f0(first(range), first(range), minimum(value(heightfield)))\nmaxi = Vec3f0(last(range), last(range), maximum(value(heightfield)))\nbars = visualize(\n    heightfield,\n    scale_x = 0.07,\n    scale_y = 0.07,\n    color_map=map(RGBA{U8}, colormap( Blues )),\n    color_norm=Vec2f0(0,1),\n    ranges=(range, range),\n    boundingbox=Signal(AABB{Float32}(mini, maxi))\n)\nview(bars, window)\n\nrenderloop(window)", 
            "title": "Bars"
        }, 
        {
            "location": "/examples/particles/#cubicles", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\ncube = HyperRectangle(Vec3f0(0), Vec3f0(0.05))\nn = 20\nconst wx,wy,wz = widths(cube)\n\nmesh = GLNormalMesh(cube)\n\ntimepi = const_lift(*, timesignal, 2f0*pi)\nfunction position(t, x, y)\n    pos = Point3f0(x*(sqrt(wx^2+wy^2)), -y*wy, y*wz)\n    dir = Point3f0(0, wy, wz)\n    pos = pos + sin(t)*dir\nend\nposition_signal = map(timepi) do t\n    vec(Point3f0[position(t,x,y) for x=1:n, y=1:n])\nend\n\nrotation = map(timepi) do t\n    vec(Vec3f0[Vec3f0(cos(t+(x/7)),sin(t+(y/7)), 1) for x=1:20, y=1:20])\nend\n\ncubes = visualize(\n    (mesh, position_signal),\n    rotation=rotation,\n    color_map=GLVisualize.default(Vector{RGBA}),\n    color_norm=Vec2f0(1,1.8)\n    # intensity that will define the color sampled from color_map will fallback\n    # to the length of the rotation vector.\n    # you could also supply it via intensity = Vector{Float32}\n)\n\n# we create our own camera to better adjust to what we want to see.\ncamera = PerspectiveCamera(\n    Signal(Vec3f0(0)), # theta (rotate by x around cam xyz axis)\n    Signal(Vec3f0(0)), # translation (translate by translation in the direction of the cam xyz axis)\n    Signal(Vec3f0(wx*n+4wx,wy*n,wz*n)/2), # lookat. We want to look at the middle of the cubes\n    Signal(Vec3f0(((wx*n+4wx)/2),1.2*wy*n,(wz*n)/2)), # camera position. We want to be on the same height, but further away in y\n    Signal(Vec3f0(0,0,1)), #upvector\n    window.area, # window area\n\n    Signal(41f0), # Field of View\n    Signal(1f0),  # Min distance (clip distance)\n    Signal(100f0), # Max distance (clip distance)\n    Signal(GLAbstraction.ORTHOGRAPHIC)\n)\nview(cubes, window, camera=camera)\n\n\nrenderloop(window)", 
            "title": "Cubicles"
        }, 
        {
            "location": "/examples/particles/#flow3d", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 7\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec3f0[(sin(x/t), cos(y/(t/2f0)), sqrt(t+z^2)) for x=1:N, y=1:N, z=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow)\nview(vis, window)\n\n renderloop(window)", 
            "title": "Flow3D"
        }, 
        {
            "location": "/examples/particles/#particles", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0, 1f0, 360))\n\ncat    = GLNormalMesh(loadasset( cat.obj ))\nsphere = GLNormalMesh(Sphere{Float32}(Vec3f0(0), 1f0), 12)\n\nfunction scale_gen(v0, nv)\n    l = length(v0)\n    @inbounds for i=1:l\n        v0[i] = Vec3f0(1,1,sin((nv*l)/i))/2\n    end\n    v0\nend\nfunction color_gen(v0, t)\n    l = length(v0)\n    @inbounds for x=1:l\n        v0[x] = RGBA{U8}(x/l,(cos(t)+1)/2,(sin(x/l/3)+1)/2.,1.)\n    end\n    v0\nend\n\nt            = const_lift(x- x+0.1, timesignal)\nps           = sphere.vertices\nscale_start  = Vec3f0[Vec3f0(1,1,rand()) for i=1:length(ps)]\nscale        = foldp(scale_gen, scale_start, t)\ncolorstart   = color_gen(zeros(RGBA{U8}, length(ps)), value(t))\ncolor        = foldp(color_gen, colorstart, t)\nrotation     = -sphere.normals\n\ncats = visualize((cat, ps), scale=scale, color=color, rotation=rotation)\n\nview(cats, window)\n\nrenderloop(window)", 
            "title": "Particles"
        }, 
        {
            "location": "/examples/particles/#sinfun", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,360))\n\nt = const_lift(*, timesignal, 2pi)\nn = 50\nconst yrange = linspace(0.03, 0.3, n)\ntrange = linspace(0, 10pi, 200)\n\nfunction gen_points(timesignal, y)\n    x = sin(timesignal+(y*60*pi*y)+y)*y*5\n    z = cos((timesignal+pi)+(y*60*pi*y)+y)*y*5\n    Point3f0(x,y*60f0,z)\nend\nfunction gen_points(timesignal)\n    Point3f0[gen_points(timesignal, y) for y in yrange]\nend\n\npositions = map(gen_points, timesignal)\nscale     = map(Vec3f0, yrange)\nprimitive = centered(Sphere)\npoints    = visualize((primitive, positions), scale=scale)\n\nview(points, window)\n\nrenderloop(window)", 
            "title": "Sinfun"
        }, 
        {
            "location": "/examples/sprites/", 
            "text": "Arrows\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 20\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec2f0[(sin(x/t), cos(y/(t/2f0))) for x=1:N, y=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow, ranges=(50:800,50:500))\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)\n\n\n\n\n\nBillboard\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, ModernGL, FileIO, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlet\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nconst b = Point3f0[(rand(Point3f0)*2)-1 for i=1:64]\n\nsprites = visualize(\n    (SimpleRectangle(0f0,0f0,0.5f0, 0.5f0), b),\n    billboard=true, image=loadasset(\ndoge.png\n),\n    model=rotation\n)\n\nview(sprites, window, camera=:perspective)\nend\n\nrenderloop(window)\n\n\n\n\n\nBouncy\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n window = glscreen()\n timesignal = bounce(linspace(0,1,50))\nn = 30\nconst border = 50f0\nfunction bounce_particles(pos_velo, _)\n    positions, velocity = pos_velo\n    dt = 0.1f0\n    @inbounds for i=1:length(positions)\n        pos,velo = positions[i], velocity[i]\n        positions[i] = Point2f0(pos[1], pos[2] + velo*dt)\n        if pos[2] \n= border\n            velocity[i] = abs(velo)\n        else\n            velocity[i] = velo - 9.8*dt\n        end\n    end\n    positions, velocity\nend\nstart_position = (rand(Point2f0, n)*700f0) + border\nposition_velocity = foldp(bounce_particles,\n    (start_position, zeros(Float32, n)),\n    timesignal\n)\ncircle = HyperSphere(Point2f0(0), 40f0)\nvis = visualize((circle, map(first, position_velocity)),\n    image=loadasset(\ndoge.png\n),\n    stroke_width=3f0,\n    stroke_color=RGBA{Float32}(0.91,0.91,0.91,1)\n)\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)\n\n\n\n\n\nDistancefield\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\nconst n1 = 30\npositions = rand(Point2f0, n1).*1000f0\n\n\nxy_data(x,y,i) = Float32(sin(y/2f0/i)+cos(i*x))\nconst n2 = 128\n# a distance field is a Matrix{Float32} array, which encodes the distance to\n# the border of a filled shape. Positive numbers are inside the shape, 0 is the\n# border and negative number are outside.\n# this is basically how we render text, since you can do anti aliasing very\n# nicely when you know the distance to the border.\n# For text we use one big texture and specify uv coordinates into this big texture\n# for every particle. How this is done can be seen in example\n# partices/sprites/image_texture_atlas.jl\n\ndfield = map(timesignal) do t\n    tpi = (2pi*t)+0.2\n    Float32[xy_data(x,y,tpi)+0.5f0 for x=1:n2, y=1:n2]\nend\nBase.rand(m::MersenneTwister, ::Type{U8}) = U8(rand(m, UInt8))\nBase.rand{T \n: Colorant}(m::MersenneTwister, ::Type{T}) = T(ntuple(x-\nrand(m, eltype(T)), Val{length(T)})...)\n\ndistfield = visualize((DISTANCEFIELD, positions),\n    stroke_width=4f0,\n    scale=Vec2f0(120),\n    stroke_color=rand(RGBA{Float32}, n1),\n    color=rand(RGBA{Float32}, n1),\n    distancefield=dfield\n)\nview(distfield, window)\n\n\n renderloop(window)\n\n\n\n\n\nImage Texture Atlas\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\n\n# this is just one big texture\ntexture_atlas = loadasset(\ndoge.png\n)\nw, h = size(texture_atlas)\nconst n = 40\nxrange = linspace(0, w, n)\nyrange = linspace(0, h, n)\nscale  = Vec2f0(step(xrange), step(yrange))\n\n# position in a grid\npositions = map(timesignal) do t\n    vec(Point2f0[(x+(sin(t*2*pi)*400),y+(sin(0+y*t*0.01)*200)+(cos(t*2*pi)*200)) for x=xrange, y=yrange])\nend\n\n# uv coordinates are normalized coordinates into the texture_atlas\n# they need the start point and the width of each rectangle (sprites are rectangles)\n# so you will not actually index with the circle primitive, but rather with\n# with the quad of the particle (the rest of the quad is transparent)\n# note, that for uv coordinates, the origin is on the top left corner\nuv_offset_width = vec(Vec4f0[(x,y,x+(1/n),y+(1/n)) for x=linspace(0, 1, n), y=linspace(1, 0, n)])\n\n# when position and scale are defined, We can leave the middle and radius of\n# Circle undefined, so just passing the type.\ndistfield = visualize((Circle, positions),\n    scale=scale,\n    stroke_width=1f0,\n    uv_offset_width=uv_offset_width,\n    stroke_color = RGBA{Float32}(0.9,0.9,0.9,1.0),\n    image=texture_atlas\n)\nview(distfield, window)\n\n\n renderloop(window)\n\n\n\n\n\nLetitsnow\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = bounce(0f0:20f0)\n\nconst S = -5f0\nconst W = 10f0\nconst N = 1000\nconst ps = (rand(Point3f0, N)*W)+S\nconst velocity = rand(Vec3f0, N)*0.01f0\nconst gravity  = Vec3f0(0,0,-0.04)\n\nupper_bound(x) = x\nS+W\nlower_bound(x) = x\nS\nfunction letitsnow(position, t)\n    @inbounds for i=1:length(ps)\n        pos = Vec(position[i])\n        p = Point3f0(pos+gravity+velocity[i])\n        if any(upper_bound, p) || any(lower_bound, p)\n            position[i] = Point3f0(rand(linspace(S,S+W, 1000)),rand(linspace(S,S+W, 1000)), S+W)\n            velocity[i] = Vec3f0(0)\n        else\n            position[i] = p\n        end\n    end\n    position\nend\nparticles       = foldp(letitsnow, ps, timesignal)\nrotation_angle  = bounce(0f0:1f0:360f0)\nrotation        = map(rotationmatrix_z, map(deg2rad, rotation_angle))\ncolor_ramp      = colormap(\nBlues\n, 50)\ncolors          = RGBA{Float32}[color_ramp[rand(1:50)] for i=1:N]\n\nsnowflakes = visualize(\n    ('\u2744', particles),\n    color=colors,\n    scale=Vec2f0(0.6), billboard=true, model=rotation\n)\n\nview(snowflakes, window, camera=:perspective)\n\n\n renderloop(window)\n\n\n\n\n\nMoving Bars\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\nwindow = glscreen()\ntimesignal = bounce(0f0:0.1:1f0)\n\nprimitive = SimpleRectangle(0f0,-0.5f0,1f0,1f0)\npositions = rand(10f0:0.01f0:200f0, 10)\n\nfunction interpolate(a, positions, t)\n    [ae+((be-ae)*t) for (ae, be) in zip(a,positions)]\nend\nt = const_lift(*, timesignal, 10f0)\ninterpolated = foldp((positions,positions,positions), t) do v0_v1_ip, td\n    v0,v1,ip = v0_v1_ip\n    pol = td%1\n    if isapprox(pol, 0.0)\n        v0 = v1\n        v1 = map(x-\n rand(linspace(-50f0, 60f0, 100)), v0)\n    end\n    v0, v1, interpolate(v0, v1, pol)\nend\nb_sig = map(last, interpolated)\nbars = visualize(\n    (RECTANGLE, b_sig),\n    intensity=b_sig,\n    ranges=linspace(0,600, 10),\n    color_norm=Vec2f0(-40,200),\n    color_map=GLVisualize.default(Vector{RGBA})\n)\nview(bars, window, camera=:orthographic_pixel)\n\nrenderloop(window)\n\n\n\n\n\nMoving Circles\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nt          = const_lift(*, timesignal, 10f0)\nradius     = 200f0\nw,h        = widths(window)\nmiddle     = Point2f0(w/2, h/2)\ncircle_pos = Point2f0[(Point2f0(sin(i), cos(i))*radius)+middle for i=linspace(0, 2pi, 20)]\nrotation   = Vec2f0[normalize(Vec2f0(middle)-Vec2f0(p)) for p in circle_pos]\nscales     = map(t) do t\n    Vec2f0[Vec2f0(30, ((sin(i+t)+1)/2)*60) for i=linspace(0, 2pi, 20)]\nend\n\ncircles = visualize(\n    (CIRCLE, circle_pos),\n    rotation=rotation, scale=scales,\n)\n\nview(circles, window)\n\nrenderloop(window)", 
            "title": "Sprites"
        }, 
        {
            "location": "/examples/sprites/#arrows", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0,1,360))\nN = 20\n# generate some rotations\nfunction rotation_func(t)\n    t = (t == 0f0 ? 0.01f0 : t)\n    Vec2f0[(sin(x/t), cos(y/(t/2f0))) for x=1:N, y=1:N]\nend\n\n# us Reactive.map to transform the timesignal signal into the arrow flow\nflow = map(rotation_func, timesignal)\n\n# create a visualisation\nvis = visualize(flow, ranges=(50:800,50:500))\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)", 
            "title": "Arrows"
        }, 
        {
            "location": "/examples/sprites/#billboard", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, GLAbstraction, ModernGL, FileIO, Reactive\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlet\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nconst b = Point3f0[(rand(Point3f0)*2)-1 for i=1:64]\n\nsprites = visualize(\n    (SimpleRectangle(0f0,0f0,0.5f0, 0.5f0), b),\n    billboard=true, image=loadasset( doge.png ),\n    model=rotation\n)\n\nview(sprites, window, camera=:perspective)\nend\n\nrenderloop(window)", 
            "title": "Billboard"
        }, 
        {
            "location": "/examples/sprites/#bouncy", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n window = glscreen()\n timesignal = bounce(linspace(0,1,50))\nn = 30\nconst border = 50f0\nfunction bounce_particles(pos_velo, _)\n    positions, velocity = pos_velo\n    dt = 0.1f0\n    @inbounds for i=1:length(positions)\n        pos,velo = positions[i], velocity[i]\n        positions[i] = Point2f0(pos[1], pos[2] + velo*dt)\n        if pos[2]  = border\n            velocity[i] = abs(velo)\n        else\n            velocity[i] = velo - 9.8*dt\n        end\n    end\n    positions, velocity\nend\nstart_position = (rand(Point2f0, n)*700f0) + border\nposition_velocity = foldp(bounce_particles,\n    (start_position, zeros(Float32, n)),\n    timesignal\n)\ncircle = HyperSphere(Point2f0(0), 40f0)\nvis = visualize((circle, map(first, position_velocity)),\n    image=loadasset( doge.png ),\n    stroke_width=3f0,\n    stroke_color=RGBA{Float32}(0.91,0.91,0.91,1)\n)\nview(vis, window, camera=:orthographic_pixel)\n\n renderloop(window)", 
            "title": "Bouncy"
        }, 
        {
            "location": "/examples/sprites/#distancefield", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\nconst n1 = 30\npositions = rand(Point2f0, n1).*1000f0\n\n\nxy_data(x,y,i) = Float32(sin(y/2f0/i)+cos(i*x))\nconst n2 = 128\n# a distance field is a Matrix{Float32} array, which encodes the distance to\n# the border of a filled shape. Positive numbers are inside the shape, 0 is the\n# border and negative number are outside.\n# this is basically how we render text, since you can do anti aliasing very\n# nicely when you know the distance to the border.\n# For text we use one big texture and specify uv coordinates into this big texture\n# for every particle. How this is done can be seen in example\n# partices/sprites/image_texture_atlas.jl\n\ndfield = map(timesignal) do t\n    tpi = (2pi*t)+0.2\n    Float32[xy_data(x,y,tpi)+0.5f0 for x=1:n2, y=1:n2]\nend\nBase.rand(m::MersenneTwister, ::Type{U8}) = U8(rand(m, UInt8))\nBase.rand{T  : Colorant}(m::MersenneTwister, ::Type{T}) = T(ntuple(x- rand(m, eltype(T)), Val{length(T)})...)\n\ndistfield = visualize((DISTANCEFIELD, positions),\n    stroke_width=4f0,\n    scale=Vec2f0(120),\n    stroke_color=rand(RGBA{Float32}, n1),\n    color=rand(RGBA{Float32}, n1),\n    distancefield=dfield\n)\nview(distfield, window)\n\n\n renderloop(window)", 
            "title": "Distancefield"
        }, 
        {
            "location": "/examples/sprites/#image-texture-atlas", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = loop(linspace(0f0, 1f0, 360))\n\n# this is just one big texture\ntexture_atlas = loadasset( doge.png )\nw, h = size(texture_atlas)\nconst n = 40\nxrange = linspace(0, w, n)\nyrange = linspace(0, h, n)\nscale  = Vec2f0(step(xrange), step(yrange))\n\n# position in a grid\npositions = map(timesignal) do t\n    vec(Point2f0[(x+(sin(t*2*pi)*400),y+(sin(0+y*t*0.01)*200)+(cos(t*2*pi)*200)) for x=xrange, y=yrange])\nend\n\n# uv coordinates are normalized coordinates into the texture_atlas\n# they need the start point and the width of each rectangle (sprites are rectangles)\n# so you will not actually index with the circle primitive, but rather with\n# with the quad of the particle (the rest of the quad is transparent)\n# note, that for uv coordinates, the origin is on the top left corner\nuv_offset_width = vec(Vec4f0[(x,y,x+(1/n),y+(1/n)) for x=linspace(0, 1, n), y=linspace(1, 0, n)])\n\n# when position and scale are defined, We can leave the middle and radius of\n# Circle undefined, so just passing the type.\ndistfield = visualize((Circle, positions),\n    scale=scale,\n    stroke_width=1f0,\n    uv_offset_width=uv_offset_width,\n    stroke_color = RGBA{Float32}(0.9,0.9,0.9,1.0),\n    image=texture_atlas\n)\nview(distfield, window)\n\n\n renderloop(window)", 
            "title": "Image Texture Atlas"
        }, 
        {
            "location": "/examples/sprites/#letitsnow", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Reactive, GLAbstraction, Colors\n\n window = glscreen()\n timesignal = bounce(0f0:20f0)\n\nconst S = -5f0\nconst W = 10f0\nconst N = 1000\nconst ps = (rand(Point3f0, N)*W)+S\nconst velocity = rand(Vec3f0, N)*0.01f0\nconst gravity  = Vec3f0(0,0,-0.04)\n\nupper_bound(x) = x S+W\nlower_bound(x) = x S\nfunction letitsnow(position, t)\n    @inbounds for i=1:length(ps)\n        pos = Vec(position[i])\n        p = Point3f0(pos+gravity+velocity[i])\n        if any(upper_bound, p) || any(lower_bound, p)\n            position[i] = Point3f0(rand(linspace(S,S+W, 1000)),rand(linspace(S,S+W, 1000)), S+W)\n            velocity[i] = Vec3f0(0)\n        else\n            position[i] = p\n        end\n    end\n    position\nend\nparticles       = foldp(letitsnow, ps, timesignal)\nrotation_angle  = bounce(0f0:1f0:360f0)\nrotation        = map(rotationmatrix_z, map(deg2rad, rotation_angle))\ncolor_ramp      = colormap( Blues , 50)\ncolors          = RGBA{Float32}[color_ramp[rand(1:50)] for i=1:N]\n\nsnowflakes = visualize(\n    ('\u2744', particles),\n    color=colors,\n    scale=Vec2f0(0.6), billboard=true, model=rotation\n)\n\nview(snowflakes, window, camera=:perspective)\n\n\n renderloop(window)", 
            "title": "Letitsnow"
        }, 
        {
            "location": "/examples/sprites/#moving-bars", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, FileIO\nusing GLAbstraction, Colors, Reactive\nwindow = glscreen()\ntimesignal = bounce(0f0:0.1:1f0)\n\nprimitive = SimpleRectangle(0f0,-0.5f0,1f0,1f0)\npositions = rand(10f0:0.01f0:200f0, 10)\n\nfunction interpolate(a, positions, t)\n    [ae+((be-ae)*t) for (ae, be) in zip(a,positions)]\nend\nt = const_lift(*, timesignal, 10f0)\ninterpolated = foldp((positions,positions,positions), t) do v0_v1_ip, td\n    v0,v1,ip = v0_v1_ip\n    pol = td%1\n    if isapprox(pol, 0.0)\n        v0 = v1\n        v1 = map(x-  rand(linspace(-50f0, 60f0, 100)), v0)\n    end\n    v0, v1, interpolate(v0, v1, pol)\nend\nb_sig = map(last, interpolated)\nbars = visualize(\n    (RECTANGLE, b_sig),\n    intensity=b_sig,\n    ranges=linspace(0,600, 10),\n    color_norm=Vec2f0(-40,200),\n    color_map=GLVisualize.default(Vector{RGBA})\n)\nview(bars, window, camera=:orthographic_pixel)\n\nrenderloop(window)", 
            "title": "Moving Bars"
        }, 
        {
            "location": "/examples/sprites/#moving-circles", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, GLAbstraction\nusing Colors, Reactive, FileIO\n\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\nt          = const_lift(*, timesignal, 10f0)\nradius     = 200f0\nw,h        = widths(window)\nmiddle     = Point2f0(w/2, h/2)\ncircle_pos = Point2f0[(Point2f0(sin(i), cos(i))*radius)+middle for i=linspace(0, 2pi, 20)]\nrotation   = Vec2f0[normalize(Vec2f0(middle)-Vec2f0(p)) for p in circle_pos]\nscales     = map(t) do t\n    Vec2f0[Vec2f0(30, ((sin(i+t)+1)/2)*60) for i=linspace(0, 2pi, 20)]\nend\n\ncircles = visualize(\n    (CIRCLE, circle_pos),\n    rotation=rotation, scale=scales,\n)\n\nview(circles, window)\n\nrenderloop(window)", 
            "title": "Moving Circles"
        }, 
        {
            "location": "/examples/text/", 
            "text": "Text\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,20))\n\n# GLAbstraction.const_lift is defined as\n# const_lift(F, args...) = Reactive.map(F, map(Signal, args)...)\n# and allows to also use constant arguments without manually wrapping\n# them into signals\n\u03c0_signal = const_lift(*, timesignal, pi)\n\n# Reactive.map takes a signal and transforms it by applying F into a new signal\n# it's similar to Base.map, just over the time dimension (like registering a\n# callback in a more traditional event system)\ns = map(\u03c0_signal) do t\n\nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\n$(t)\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\n$(t) mm\nI can't even...\n\n\nend\n\n# view and visualize it!\nview(visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)) # move this up, since the text starts at 0 and goes down from there\n), window)\n\nrenderloop(window)\n\n\n\n\n\nText Particle\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# Did we mention, that text is just a normal sprite particle system?\n# This means, it supports all the attributes like the other particle systems.\n\n# some text again\ns = \nThe quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5 \n a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\nI can't even...\n\n\n\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    t2\u03c0 = t*pi*2\n    Vec3f0(cos(t2\u03c0),sin(t2\u03c0), 1)\nend\n\n# create some funcy scale change\nscale = map(timesignal) do t\n    circular = sin(t*pi)\n    Vec2f0(1+circular*0.5,1+circular*0.5)\nend\nconst len = length(s)\n\n# per glyph color\ncolor = map(timesignal) do t\n    RGBA{Float32}[RGBA{Float32}(i/len,1, (sin(t)+1.)/2., 1) for i=1:len]\nend\n\n# per glyph stroke color\nstroke_color = RGBA{Float32}[RGBA{Float32}(0,0,0, i/len) for i=1:len]\n\n# view and visualize it!\n# you could also pass positions as a keyword argument or make\n# the scale/rotation per glyph by supplying a Vector of them.\ntextvizz = visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)), # move this up, since the text starts at 0 and goes down from there\n    rotation=rotation,\n    color=color,\n    stroke_color=stroke_color,\n    stroke_width = 1f0,\n    relative_scale=scale\n)\n\nview(textvizz, window)\n\nrenderloop(window)", 
            "title": "Text"
        }, 
        {
            "location": "/examples/text/#text", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0,1,20))\n\n# GLAbstraction.const_lift is defined as\n# const_lift(F, args...) = Reactive.map(F, map(Signal, args)...)\n# and allows to also use constant arguments without manually wrapping\n# them into signals\n\u03c0_signal = const_lift(*, timesignal, pi)\n\n# Reactive.map takes a signal and transforms it by applying F into a new signal\n# it's similar to Base.map, just over the time dimension (like registering a\n# callback in a more traditional event system)\ns = map(\u03c0_signal) do t The quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\n$(t)\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5   a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\n$(t) mm\nI can't even... \nend\n\n# view and visualize it!\nview(visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)) # move this up, since the text starts at 0 and goes down from there\n), window)\n\nrenderloop(window)", 
            "title": "Text"
        }, 
        {
            "location": "/examples/text/#text-particle", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Colors, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\n# Did we mention, that text is just a normal sprite particle system?\n# This means, it supports all the attributes like the other particle systems.\n\n# some text again\ns =  The quick brown fox jumped over\nsome lazy text sample.\nHe wasn't really into numbers, but it's\nreally important to try out number rendering:\nThis number goes from 0 to \u03c0 in no time!\nAnd then back to 0 again... Wow!\nThis is real crazy stuff,\nbut it gets even more ludicrous:\n\u222e E\u22c5da = Q,  n \u2192 \u221e, \u2211 f(i) = \u220f g(i),\n\u2200x\u2208\u211d: \u2308x\u2309 = \u2212\u230a\u2212x\u230b, \u03b1 \u2227 \u00ac\u03b2 = \u00ac(\u00ac\u03b1 \u2228 \u03b2),\n\u2115 \u2286 \u2115\u2080 \u2282 \u2124 \u2282 \u211a \u2282 \u211d \u2282 \u2102,\n\u22a5   a \u2260 b \u2261 c \u2264 d \u226a \u22a4 \u21d2 (A \u21d4 B),\n2H\u2082 + O\u2082 \u21cc 2H\u2082O, R = 4.7 k\u03a9, \u2300\nI can't even... \n\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    t2\u03c0 = t*pi*2\n    Vec3f0(cos(t2\u03c0),sin(t2\u03c0), 1)\nend\n\n# create some funcy scale change\nscale = map(timesignal) do t\n    circular = sin(t*pi)\n    Vec2f0(1+circular*0.5,1+circular*0.5)\nend\nconst len = length(s)\n\n# per glyph color\ncolor = map(timesignal) do t\n    RGBA{Float32}[RGBA{Float32}(i/len,1, (sin(t)+1.)/2., 1) for i=1:len]\nend\n\n# per glyph stroke color\nstroke_color = RGBA{Float32}[RGBA{Float32}(0,0,0, i/len) for i=1:len]\n\n# view and visualize it!\n# you could also pass positions as a keyword argument or make\n# the scale/rotation per glyph by supplying a Vector of them.\ntextvizz = visualize(s,\n    model=translationmatrix(Vec3f0(0,600,0)), # move this up, since the text starts at 0 and goes down from there\n    rotation=rotation,\n    color=color,\n    stroke_color=stroke_color,\n    stroke_width = 1f0,\n    relative_scale=scale\n)\n\nview(textvizz, window)\n\nrenderloop(window)", 
            "title": "Text Particle"
        }, 
        {
            "location": "/examples/lines/", 
            "text": "Contourlines\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing Contour, GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nxrange = -5f0:0.02f0:5f0\nyrange = -5f0:0.02f0:5f0\n\nz = Float32[sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x) for x in xrange, y in yrange]\nmini = minimum(z)\nmaxi = maximum(z)\ncolor_ramp = map(x-\nRGBA{Float32}(x, 1.0), colormap(\nBlues\n))\nheight2color(val, mini, maxi) = color_ramp[floor(Int, (((val-mini)/(maxi-mini))*(length(color_ramp)-1)))+1]\n\nfor h in mini:0.2f0:maxi\n    c = contour(xrange, yrange, z, h)\n    for elem in c.lines\n        points = map(elem.vertices) do p\n            Point3f0(p, h)\n        end\n        line_renderable = visualize(\n            points, :lines,\n            color=height2color(h, mini, maxi),\n            model=rotation\n        )\n        view(line_renderable, window, camera=:perspective)\n    end\nend\n\n renderloop(window)\n\n\n\n\n\nLines3D\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLAbstraction, Colors, GeometryTypes, GLVisualize, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n\nn = 400 # The number of points per line\nnloops = 20 # The number of loops\n# The scalar parameter for each line\nTL = linspace(-2f0 * pi, 2f0 * pi, n)\n# We create a list of positions and connections, each describing a line.\n# We will collapse them in one array before plotting.\nxyz    = Point3f0[]\ncolors = RGBA{Float32}[]\n\n# creates some distinguishable colors from which we can sample for each line\nbase_colors1 = distinguishable_colors(nloops, RGB{Float64}(1,0,0))\n# Create each line one after the other in a loop\nfor i=1:nloops\n    append!(xyz, [Point3f0(sin(t), cos((2 + .02 * i) * t), cos((3 + .03 * i) * t)) for t in TL])\n    unique_colors = base_colors1[i]\n    hsv = HSV(unique_colors)\n    color_palette = map(x-\nRGBA{Float32}(x, 1.0), sequential_palette(hsv.h, n, s=hsv.s))\n    append!(colors, color_palette)\nend\n\n# map comes from Reactive.jl and allows you to map any Signal to another.\n# In this case we create a rotation matrix from the timesignal signal.\n\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -\n 4x4 Float32 rotation matrix\nend\n\nlines3d = visualize(xyz, :lines, color=colors, model=rotation)\n\nview(lines3d, window, camera=:perspective)\n\n renderloop(window)\n\n\n\n\n\nLinesegments3d\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, Colors\nusing Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlarge_sphere = HyperSphere(Point3f0(0), 1f0)\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\npositions = decompose(Point3f0, large_sphere)\nindices = rand(range(Cuint(0), Cuint(length(positions))), 1000)\n\ncolor = map(large_sphere-\nRGBA{Float32}(large_sphere, 0.9f0), colormap(\nBlues\n, length(positions)))\ncolor2 = map(large_sphere-\nRGBA{Float32}(large_sphere, 1f0), colormap(\nBlues\n, length(positions)))\n\nlines = visualize(\n    positions, :linesegment, thickness=0.5f0,\n    color=color, indices=indices, model=rotation\n)\nspheres = visualize(\n    (Sphere{Float32}(Point3f0(0.0), 1f0), positions),\n    color=color2, scale=Vec3f0(0.05), model=rotation\n)\nview(lines, window, camera=:perspective)\nview(spheres, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/lines/#contourlines", 
            "text": "Your browser does not support the video tag.  using Contour, GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n# create a rotation from the time signal\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -  4x4 Float32 rotation matrix\nend\n\nxrange = -5f0:0.02f0:5f0\nyrange = -5f0:0.02f0:5f0\n\nz = Float32[sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x) for x in xrange, y in yrange]\nmini = minimum(z)\nmaxi = maximum(z)\ncolor_ramp = map(x- RGBA{Float32}(x, 1.0), colormap( Blues ))\nheight2color(val, mini, maxi) = color_ramp[floor(Int, (((val-mini)/(maxi-mini))*(length(color_ramp)-1)))+1]\n\nfor h in mini:0.2f0:maxi\n    c = contour(xrange, yrange, z, h)\n    for elem in c.lines\n        points = map(elem.vertices) do p\n            Point3f0(p, h)\n        end\n        line_renderable = visualize(\n            points, :lines,\n            color=height2color(h, mini, maxi),\n            model=rotation\n        )\n        view(line_renderable, window, camera=:perspective)\n    end\nend\n\n renderloop(window)", 
            "title": "Contourlines"
        }, 
        {
            "location": "/examples/lines/#lines3d", 
            "text": "Your browser does not support the video tag.  using GLAbstraction, Colors, GeometryTypes, GLVisualize, Reactive\n\n window = glscreen()\n timesignal = bounce(linspace(0.0, 1.0, 360))\n\nn = 400 # The number of points per line\nnloops = 20 # The number of loops\n# The scalar parameter for each line\nTL = linspace(-2f0 * pi, 2f0 * pi, n)\n# We create a list of positions and connections, each describing a line.\n# We will collapse them in one array before plotting.\nxyz    = Point3f0[]\ncolors = RGBA{Float32}[]\n\n# creates some distinguishable colors from which we can sample for each line\nbase_colors1 = distinguishable_colors(nloops, RGB{Float64}(1,0,0))\n# Create each line one after the other in a loop\nfor i=1:nloops\n    append!(xyz, [Point3f0(sin(t), cos((2 + .02 * i) * t), cos((3 + .03 * i) * t)) for t in TL])\n    unique_colors = base_colors1[i]\n    hsv = HSV(unique_colors)\n    color_palette = map(x- RGBA{Float32}(x, 1.0), sequential_palette(hsv.h, n, s=hsv.s))\n    append!(colors, color_palette)\nend\n\n# map comes from Reactive.jl and allows you to map any Signal to another.\n# In this case we create a rotation matrix from the timesignal signal.\n\nrotation = map(timesignal) do t\n    rotationmatrix_z(Float32(t*2pi)) # -  4x4 Float32 rotation matrix\nend\n\nlines3d = visualize(xyz, :lines, color=colors, model=rotation)\n\nview(lines3d, window, camera=:perspective)\n\n renderloop(window)", 
            "title": "Lines3D"
        }, 
        {
            "location": "/examples/lines/#linesegments3d", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, Colors\nusing Reactive, GLAbstraction\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0, 1f0, 360))\n\nlarge_sphere = HyperSphere(Point3f0(0), 1f0)\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\npositions = decompose(Point3f0, large_sphere)\nindices = rand(range(Cuint(0), Cuint(length(positions))), 1000)\n\ncolor = map(large_sphere- RGBA{Float32}(large_sphere, 0.9f0), colormap( Blues , length(positions)))\ncolor2 = map(large_sphere- RGBA{Float32}(large_sphere, 1f0), colormap( Blues , length(positions)))\n\nlines = visualize(\n    positions, :linesegment, thickness=0.5f0,\n    color=color, indices=indices, model=rotation\n)\nspheres = visualize(\n    (Sphere{Float32}(Point3f0(0.0), 1f0), positions),\n    color=color2, scale=Vec3f0(0.05), model=rotation\n)\nview(lines, window, camera=:perspective)\nview(spheres, window, camera=:perspective)\n\n\nrenderloop(window)", 
            "title": "Linesegments3d"
        }, 
        {
            "location": "/examples/surfaces/", 
            "text": "Juliaset\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction\n\n window = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction juliadata(max_iterations, imgx, imgy)\n    scalex, scaley = 4.0/imgx, 4.0/imgy\n\n    # initialize our Float32 heightfield\n    heightfield = zeros(Float32, imgx, imgy)\n\n    # do julia set magic!\n    for x=1:imgx, y=1:imgy\n        cy = y * scaley - 2.0\n        cx = x * scalex - 2.0\n        z = Complex(cx, cy)\n        c = Complex(-0.4, 0.6)\n        i = 0\n        for t in 0:max_iterations\n            if norm(z) \n 2.0\n                break\n            end\n            z = z * z + c\n            i = t\n        end\n        heightfield[x,y] = -(i/512f0)\n    end\n    heightfield\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nheightfield = juliadata(256, 700, 700)\n\n# visualize the heightfield as a surface\nvis = visualize(\n    heightfield, :surface,\n    model=rotation\n)\n\n# display it on the window\nview(vis, window)\n\nend\n\n renderloop(window) # render!\n\n\n\n\n\nMesh\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction, GeometryTypes, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction mgrid(dim1, dim2)\n    X = [i for i in dim1, j in dim2]\n    Y = [j for i in dim1, j in dim2]\n    return X,Y\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\ndphi, dtheta = pi/200.0f0, pi/200.0f0\n\nphi,theta = mgrid(0f0:dphi:(pi+dphi*1.5f0), 0f0:dtheta:(2f0*pi+dtheta*1.5f0));\nm0 = 4f0; m1 = 3f0; m2 = 2f0; m3 = 3f0; m4 = 6f0; m5 = 2f0; m6 = 6f0; m7 = 4f0;\na = sin(m0*phi).^m1;\nb = cos(m2*phi).^m3;\nc = sin(m4*theta).^m5;\nd = cos(m6*theta).^m7;\nr = a + b + c + d;\nx = r.*sin(phi).*cos(theta);\ny = r.*cos(phi);\nz = r.*sin(phi).*sin(theta);\n\n\nsurface = visualize((x,y,z), :surface, model=rotation)\nview(surface, window)\n\nend\n\nrenderloop(window)\n\n\n\n\n\nSurface\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLAbstraction, Colors, Reactive, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# generate some pretty data\nfunction xy_data(x,y,i, N)\n    x = ((x/N)-0.5f0)*i\n    y = ((y/N)-0.5f0)*i\n    r = sqrt(x*x + y*y)\n    Float32(sin(r)/r)\nend\n\nsurf(i, N) = Float32[xy_data(x, y, i, N) for x=1:N, y=1:N]\n\nt = map(t-\n(t*30f0)+20f0, timesignal)\n\nbb = Signal(AABB{Float32}(Vec3f0(0), Vec3f0(1)))\n\nview(visualize(const_lift(surf, t, 400), :surface, boundingbox=bb))\n\nrenderloop(window)", 
            "title": "Surfaces"
        }, 
        {
            "location": "/examples/surfaces/#juliaset", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GLAbstraction\n\n window = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction juliadata(max_iterations, imgx, imgy)\n    scalex, scaley = 4.0/imgx, 4.0/imgy\n\n    # initialize our Float32 heightfield\n    heightfield = zeros(Float32, imgx, imgy)\n\n    # do julia set magic!\n    for x=1:imgx, y=1:imgy\n        cy = y * scaley - 2.0\n        cx = x * scalex - 2.0\n        z = Complex(cx, cy)\n        c = Complex(-0.4, 0.6)\n        i = 0\n        for t in 0:max_iterations\n            if norm(z)   2.0\n                break\n            end\n            z = z * z + c\n            i = t\n        end\n        heightfield[x,y] = -(i/512f0)\n    end\n    heightfield\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\nheightfield = juliadata(256, 700, 700)\n\n# visualize the heightfield as a surface\nvis = visualize(\n    heightfield, :surface,\n    model=rotation\n)\n\n# display it on the window\nview(vis, window)\n\nend\n\n renderloop(window) # render!", 
            "title": "Juliaset"
        }, 
        {
            "location": "/examples/surfaces/#mesh", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GLAbstraction, GeometryTypes, Reactive\n\nwindow = glscreen()\n timesignal = loop(linspace(0f0,1f0,360))\n\nfunction mgrid(dim1, dim2)\n    X = [i for i in dim1, j in dim2]\n    Y = [j for i in dim1, j in dim2]\n    return X,Y\nend\n\nlet\n\nrotation_angle = const_lift(*, timesignal, 2f0*pi)\nrotation = map(rotationmatrix_z, rotation_angle)\n\ndphi, dtheta = pi/200.0f0, pi/200.0f0\n\nphi,theta = mgrid(0f0:dphi:(pi+dphi*1.5f0), 0f0:dtheta:(2f0*pi+dtheta*1.5f0));\nm0 = 4f0; m1 = 3f0; m2 = 2f0; m3 = 3f0; m4 = 6f0; m5 = 2f0; m6 = 6f0; m7 = 4f0;\na = sin(m0*phi).^m1;\nb = cos(m2*phi).^m3;\nc = sin(m4*theta).^m5;\nd = cos(m6*theta).^m7;\nr = a + b + c + d;\nx = r.*sin(phi).*cos(theta);\ny = r.*cos(phi);\nz = r.*sin(phi).*sin(theta);\n\n\nsurface = visualize((x,y,z), :surface, model=rotation)\nview(surface, window)\n\nend\n\nrenderloop(window)", 
            "title": "Mesh"
        }, 
        {
            "location": "/examples/surfaces/#surface", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GLAbstraction, Colors, Reactive, GeometryTypes\n\nwindow = glscreen()\ntimesignal = loop(linspace(0f0,1f0,360))\n\n# generate some pretty data\nfunction xy_data(x,y,i, N)\n    x = ((x/N)-0.5f0)*i\n    y = ((y/N)-0.5f0)*i\n    r = sqrt(x*x + y*y)\n    Float32(sin(r)/r)\nend\n\nsurf(i, N) = Float32[xy_data(x, y, i, N) for x=1:N, y=1:N]\n\nt = map(t- (t*30f0)+20f0, timesignal)\n\nbb = Signal(AABB{Float32}(Vec3f0(0), Vec3f0(1)))\n\nview(visualize(const_lift(surf, t, 400), :surface, boundingbox=bb))\n\nrenderloop(window)", 
            "title": "Surface"
        }, 
        {
            "location": "/examples/meshes/", 
            "text": "Meshes\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\n\nmsh = GLNormalMesh(loadasset(\ncat.obj\n))\n\nview(visualize(msh), window)\n\nrenderloop(window)", 
            "title": "Meshes"
        }, 
        {
            "location": "/examples/meshes/#meshes", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GeometryTypes, GLAbstraction, Colors, FileIO\n\nwindow = glscreen()\n\nmsh = GLNormalMesh(loadasset( cat.obj ))\n\nview(visualize(msh), window)\n\nrenderloop(window)", 
            "title": "Meshes"
        }, 
        {
            "location": "/examples/volumes/", 
            "text": "Volume\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GLVisualize, GLWindow\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nfunction volume_data(N)\n    volume  = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(volume)\n    min     = minimum(volume)\n    volume  = (volume .- min) ./ (max .- min)\nend\n\nvolume = visualize(volume_data(128), :iso, isovalue=timesignal)\nview(volume, window)\n\n\nrenderloop(window)", 
            "title": "Volumes"
        }, 
        {
            "location": "/examples/volumes/#volume", 
            "text": "Your browser does not support the video tag.  using GLVisualize, GLWindow\n\nwindow = glscreen()\ntimesignal = bounce(linspace(0f0,1f0,360))\n\nfunction volume_data(N)\n    volume  = Float32[sin(x/15.0)+sin(y/15.0)+sin(z/15.0) for x=1:N, y=1:N, z=1:N]\n    max     = maximum(volume)\n    min     = minimum(volume)\n    volume  = (volume .- min) ./ (max .- min)\nend\n\nvolume = visualize(volume_data(128), :iso, isovalue=timesignal)\nview(volume, window)\n\n\nrenderloop(window)", 
            "title": "Volume"
        }, 
        {
            "location": "/examples/interactive/", 
            "text": "Color Edit\n\n\n# using GLVisualize, Colors, ModernGL, GeometryTypes, GLAbstraction, GLWindow, FileIO\n# w = glscreen()\n# v, colortex = vizzedit(map(RGBA{U8}, colormap(\nblues\n, 7)), w)\n\n# function screen(robj, w)\n#   bb = boundingbox(robj)\n#   area = const_lift(bb) do b\n#       m = Vec{2,Int}(b.minimum)\n#       SimpleRectangle{Int}(m..., (Vec{2,Int}(b.maximum+30)-m)...)\n#   end\n#   s = Screen(w, area=area)\n#   transformation(robj, translationmatrix(Vec3f0(15,15,0)))\n#   view(robj, s, camera=:fixed_pixel)\n#   s\n# end\n\n# screen(v, w)\n# view(visualize(rand(Float32, 28,92), color=colortex, color_norm=Vec2f0(0,1)))\n# renderloop()\n\n\n\n\n\nGraph Editing\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, Reactive, GLWindow, GLFW\n\nwindow = glscreen()\n\nn = 50\nn_connections = 100\na = rand(Point2f0, n)*1000f0\npoints = visualize((Circle(Point2f0(0), 15f0), a))\n\nconst point_robj = points.children[] # temporary way of getting the render object. Shouldn't stay like this\n # best way to get the gpu object. One could also start by creating a gpu array oneself.\n # this is a bit tricky, since not there are three different types.\n # for points and lines you need a GLBuffer. e.g gpu_position = GLBuffer(rand(Point2f0, 50)*1000f0)\nconst gpu_position = point_robj[:position]\n# now the lines and points share the same gpu object\n# for linesegments, you can pass indices, which needs to be of some 32bit int type\nlines  = visualize(gpu_position, :linesegment, indices=rand(1:n, n_connections))\n\n# current tuple of renderobject id and index into the gpu array\nconst m2id = GLWindow.mouse2id(window)\nisoverpoint = const_lift(is_same_id, m2id, point_robj)\n\n# inputs are a dict, materialize gets the keys out of it (equivalent to mouseposition = window.inputs[:mouseposition])\n@materialize mouse_buttons_pressed, mouseposition = window.inputs\n\n# single left mousekey pressed (while no other mouse key is pressed)\nkey_pressed = const_lift(GLAbstraction.singlepressed, mouse_buttons_pressed, GLFW.MOUSE_BUTTON_LEFT)\n# dragg while key_pressed. Drag only starts if isoverpoint is true\nmousedragg  = GLAbstraction.dragged(mouseposition, key_pressed, isoverpoint)\n\n# use mousedrag and mouseid + index to actually change the gpu array with the positions\npreserve(foldp((value(m2id)..., Point2f0(0)), mousedragg) do v0, dragg\n    if dragg == Vec2f0(0) # if drag just started. Not the best way, maybe dragged should return a tuple of (draggvalue, started)\n        id, index = value(m2id)\n        if id==point_robj.id \n length(gpu_position) \n= index\n            p0 = gpu_position[index]\n        else\n            p0 = v0[3]\n        end\n    else\n        id, index, p0 = v0\n        if id==point_robj.id \n length(gpu_position) \n= index\n            gpu_position[index] = Point2f0(p0) + Point2f0(dragg)\n        end\n\n    end\n    return id, index, p0\nend)\n# view it!\nview(lines, window, camera=:fixed_pixel)\nview(points, window, camera=:fixed_pixel)\n\n renderloop(window)\n\n\n\n\n\nImage Processing\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing Images, Colors, GeometryTypes\nusing Reactive, FileIO, GLVisualize\nusing GLAbstraction, GeometryTypes, GLWindow\n\nwindow = glscreen()\n\n# loadasset loads data from the GLVisualize asset folder and is defined as\n# FileIO.load(assetpath(name))\ndoge = loadasset(\ndoge.png\n)\n# Convert to RGBA{Float32}. Float for filtering and 32 because it fits the GPU better\nimg = map(RGBA{Float32}, doge)\n# create a slider that goes from 1-20 in 0.1 steps\nslider_s, slider = vizzedit(1f0:0.1f0:20f0, window)\n\n# performant conversion to RGBAU8, implemted with a functor\n# in 0.5 anonymous functions offer the same speed, so this wouldn't be needed\nimmutable ClampRGBAU8 end\ncall(::ClampRGBAU8, x) = RGBA{U8}(clamp(comp1(x), 0,1), clamp(comp2(x), 0,1), clamp(comp3(x), 0,1), clamp(alpha(x), 0,1))\n\n\n\nApplies a gaussian filter to `img` and converts it to RGBA{U8}\n\n\nfunction myfilter(img, sigma)\n    img = Images.imfilter_gaussian(img, [sigma, sigma])\n    map(ClampRGBAU8(), img).data\nend\n\n\nstartvalue = myfilter(img, value(slider_s))\n# Use Reactive.async_map, to filter the image without blocking the main process\ntask, imgsig = async_map(myfilter, startvalue, Signal(img), slider_s)\n# visualize the image signal\nimage_renderable = visualize(imgsig, model=translationmatrix(Vec3f0(50,100,0)))\nview(image_renderable)\n\nvec2i(a,b,x...) = Vec{2,Int}(round(Int, a), round(Int, b))\nvec2i(vec::Vec) = vec2i(vec...)\n\n\ncreates a rectangle around `robj`\n\n\nfunction screen(robj)\n    bb = value(boundingbox(robj))\n    m  = vec2i(minimum(bb))\n    area = SimpleRectangle{Float32}(0,0, ((vec2i(maximum(bb))-m)+30)...)\n\n    view(visualize((area, [Point2f0(0)]),\n        color=RGBA{Float32}(0,0,0,0), stroke_color=RGBA{Float32}(0,0,0,0.7),\n        stroke_width=2f0),\n        camera=:fixed_pixel\n    )\n    robj.children[][:model] = translationmatrix(Vec3f0(15,15,0)-minimum(bb))\n    view(robj, camera=:fixed_pixel)\nend\nscreen(slider)\n\nrenderloop(window)\n\n\n\n\n\nMario Game\n\n\n\n  \n\n      Your browser does not support the video tag.\n\n\n\n\nusing GeometryTypes, GLVisualize, GLAbstraction, ImageMagick\nusing FileIO, ColorTypes, Reactive\n\n window = glscreen()\n\ntype Mario{T}\n    x           ::T\n    y           ::T\n    vx          ::T\n    vy          ::T\n    direction   ::Symbol\nend\n\n\n\ngravity(dt, mario) = (mario.vy = (mario.y \n 0.0 ? mario.vy - (dt/4.0) : 0.0); mario)\n\nfunction physics(dt, mario)\n    mario.x = mario.x + dt * mario.vx\n    mario.y = max(0.0, mario.y + dt * mario.vy)\n    mario\nend\n\nfunction walk(keys, mario)\n    mario.vx = keys[1]\n    mario.direction = keys[1] \n 0.0 ? :left : keys[1] \n 0.0 ? :right : mario.direction\n    mario\nend\n\nfunction jump(keys, mario)\n    if keys[2] \n 0.0 \n mario.vy == 0.0\n        mario.vy = 6.0\n    end\n    mario\nend\n\nfunction update(dt, keys, mario)\n    mario = gravity(dt, mario)\n    mario = jump(keys,  mario)\n    mario = walk(keys,  mario)\n    mario = physics(dt, mario)\n    mario\nend\n\n\n\nmario2model(mario) = translationmatrix(Vec3f0(mario.x, mario.y, 0f0))*scalematrix(Vec3f0(5f0))\n\nconst mario_images = Dict()\n\n\nfunction play(x::Vector)\n    const_lift(getindex, x, loop(1:length(x)))\nend\n\nfunction read_sequence(path)\n    if isdir(path)\n        return map(load, sort(map(x-\njoinpath(path, x), readdir(path))))\n    else\n        return fill(load(path), 1)\n    end\nend\n\nfor verb in [\njump\n, \nwalk\n, \nstand\n], dir in [\nleft\n, \nright\n]\n    pic = dir\n    if verb != \nwalk\n # not a sequemce\n        pic *= \n.png\n\n    end\n    path = assetpath(\nmario\n, verb, pic)\n    sequence = read_sequence(path)\n    gif = map(img-\nmap(RGBA{U8}, img), sequence)\n    mario_images[verb*dir] = play(gif)\nend\nfunction mario2image(mario, images=mario_images)\n    verb = mario.y \n 0.0 ? \njump\n : mario.vx != 0.0 ? \nwalk\n : \nstand\n\n    mario_images[verb*string(mario.direction)].value # is a signal of pictures itself (animation), so .value samples the current image\nend\nfunction arrows2vec(direction)\n    direction == :up    \n return Vec2f0( 0.0,  1.0)\n    direction == :down  \n return Vec2f0( 0.0, -1.0)\n    direction == :right \n return Vec2f0( 3.0,  0.0)\n    direction == :left  \n return Vec2f0(-3.0,  0.0)\n    Vec2f0(0.0)\nend\n\n# Put everything together\narrows          = sampleon(bounce(1:10), window.inputs[:arrow_navigation])\nkeys            = const_lift(arrows2vec, arrows)\nmario_signal    = const_lift(update, 8.0, keys, Mario(0.0, 0.0, 0.0, 0.0, :right))\nimage_stream    = const_lift(mario2image, mario_signal)\nmodelmatrix     = const_lift(mario2model, mario_signal)\n\nmario = visualize(image_stream, model=modelmatrix)\n\nview(mario, window, camera=:fixed_pixel)\n\n renderloop(window)", 
            "title": "Interactive"
        }, 
        {
            "location": "/examples/interactive/#color-edit", 
            "text": "# using GLVisualize, Colors, ModernGL, GeometryTypes, GLAbstraction, GLWindow, FileIO\n# w = glscreen()\n# v, colortex = vizzedit(map(RGBA{U8}, colormap( blues , 7)), w)\n\n# function screen(robj, w)\n#   bb = boundingbox(robj)\n#   area = const_lift(bb) do b\n#       m = Vec{2,Int}(b.minimum)\n#       SimpleRectangle{Int}(m..., (Vec{2,Int}(b.maximum+30)-m)...)\n#   end\n#   s = Screen(w, area=area)\n#   transformation(robj, translationmatrix(Vec3f0(15,15,0)))\n#   view(robj, s, camera=:fixed_pixel)\n#   s\n# end\n\n# screen(v, w)\n# view(visualize(rand(Float32, 28,92), color=colortex, color_norm=Vec2f0(0,1)))\n# renderloop()", 
            "title": "Color Edit"
        }, 
        {
            "location": "/examples/interactive/#graph-editing", 
            "text": "Your browser does not support the video tag.  using GeometryTypes, GLVisualize, GLAbstraction, Reactive, GLWindow, GLFW\n\nwindow = glscreen()\n\nn = 50\nn_connections = 100\na = rand(Point2f0, n)*1000f0\npoints = visualize((Circle(Point2f0(0), 15f0), a))\n\nconst point_robj = points.children[] # temporary way of getting the render object. Shouldn't stay like this\n # best way to get the gpu object. One could also start by creating a gpu array oneself.\n # this is a bit tricky, since not there are three different types.\n # for points and lines you need a GLBuffer. e.g gpu_position = GLBuffer(rand(Point2f0, 50)*1000f0)\nconst gpu_position = point_robj[:position]\n# now the lines and points share the same gpu object\n# for linesegments, you can pass indices, which needs to be of some 32bit int type\nlines  = visualize(gpu_position, :linesegment, indices=rand(1:n, n_connections))\n\n# current tuple of renderobject id and index into the gpu array\nconst m2id = GLWindow.mouse2id(window)\nisoverpoint = const_lift(is_same_id, m2id, point_robj)\n\n# inputs are a dict, materialize gets the keys out of it (equivalent to mouseposition = window.inputs[:mouseposition])\n@materialize mouse_buttons_pressed, mouseposition = window.inputs\n\n# single left mousekey pressed (while no other mouse key is pressed)\nkey_pressed = const_lift(GLAbstraction.singlepressed, mouse_buttons_pressed, GLFW.MOUSE_BUTTON_LEFT)\n# dragg while key_pressed. Drag only starts if isoverpoint is true\nmousedragg  = GLAbstraction.dragged(mouseposition, key_pressed, isoverpoint)\n\n# use mousedrag and mouseid + index to actually change the gpu array with the positions\npreserve(foldp((value(m2id)..., Point2f0(0)), mousedragg) do v0, dragg\n    if dragg == Vec2f0(0) # if drag just started. Not the best way, maybe dragged should return a tuple of (draggvalue, started)\n        id, index = value(m2id)\n        if id==point_robj.id   length(gpu_position)  = index\n            p0 = gpu_position[index]\n        else\n            p0 = v0[3]\n        end\n    else\n        id, index, p0 = v0\n        if id==point_robj.id   length(gpu_position)  = index\n            gpu_position[index] = Point2f0(p0) + Point2f0(dragg)\n        end\n\n    end\n    return id, index, p0\nend)\n# view it!\nview(lines, window, camera=:fixed_pixel)\nview(points, window, camera=:fixed_pixel)\n\n renderloop(window)", 
            "title": "Graph Editing"
        }, 
        {
            "location": "/examples/interactive/#image-processing", 
            "text": "Your browser does not support the video tag.  using Images, Colors, GeometryTypes\nusing Reactive, FileIO, GLVisualize\nusing GLAbstraction, GeometryTypes, GLWindow\n\nwindow = glscreen()\n\n# loadasset loads data from the GLVisualize asset folder and is defined as\n# FileIO.load(assetpath(name))\ndoge = loadasset( doge.png )\n# Convert to RGBA{Float32}. Float for filtering and 32 because it fits the GPU better\nimg = map(RGBA{Float32}, doge)\n# create a slider that goes from 1-20 in 0.1 steps\nslider_s, slider = vizzedit(1f0:0.1f0:20f0, window)\n\n# performant conversion to RGBAU8, implemted with a functor\n# in 0.5 anonymous functions offer the same speed, so this wouldn't be needed\nimmutable ClampRGBAU8 end\ncall(::ClampRGBAU8, x) = RGBA{U8}(clamp(comp1(x), 0,1), clamp(comp2(x), 0,1), clamp(comp3(x), 0,1), clamp(alpha(x), 0,1)) \nApplies a gaussian filter to `img` and converts it to RGBA{U8} \nfunction myfilter(img, sigma)\n    img = Images.imfilter_gaussian(img, [sigma, sigma])\n    map(ClampRGBAU8(), img).data\nend\n\n\nstartvalue = myfilter(img, value(slider_s))\n# Use Reactive.async_map, to filter the image without blocking the main process\ntask, imgsig = async_map(myfilter, startvalue, Signal(img), slider_s)\n# visualize the image signal\nimage_renderable = visualize(imgsig, model=translationmatrix(Vec3f0(50,100,0)))\nview(image_renderable)\n\nvec2i(a,b,x...) = Vec{2,Int}(round(Int, a), round(Int, b))\nvec2i(vec::Vec) = vec2i(vec...) \ncreates a rectangle around `robj` \nfunction screen(robj)\n    bb = value(boundingbox(robj))\n    m  = vec2i(minimum(bb))\n    area = SimpleRectangle{Float32}(0,0, ((vec2i(maximum(bb))-m)+30)...)\n\n    view(visualize((area, [Point2f0(0)]),\n        color=RGBA{Float32}(0,0,0,0), stroke_color=RGBA{Float32}(0,0,0,0.7),\n        stroke_width=2f0),\n        camera=:fixed_pixel\n    )\n    robj.children[][:model] = translationmatrix(Vec3f0(15,15,0)-minimum(bb))\n    view(robj, camera=:fixed_pixel)\nend\nscreen(slider)\n\nrenderloop(window)", 
            "title": "Image Processing"
        }, 
        {
            "location": "/examples/interactive/#mario-game", 
            "text": "Your browser does not support the video tag.  using GeometryTypes, GLVisualize, GLAbstraction, ImageMagick\nusing FileIO, ColorTypes, Reactive\n\n window = glscreen()\n\ntype Mario{T}\n    x           ::T\n    y           ::T\n    vx          ::T\n    vy          ::T\n    direction   ::Symbol\nend\n\n\n\ngravity(dt, mario) = (mario.vy = (mario.y   0.0 ? mario.vy - (dt/4.0) : 0.0); mario)\n\nfunction physics(dt, mario)\n    mario.x = mario.x + dt * mario.vx\n    mario.y = max(0.0, mario.y + dt * mario.vy)\n    mario\nend\n\nfunction walk(keys, mario)\n    mario.vx = keys[1]\n    mario.direction = keys[1]   0.0 ? :left : keys[1]   0.0 ? :right : mario.direction\n    mario\nend\n\nfunction jump(keys, mario)\n    if keys[2]   0.0   mario.vy == 0.0\n        mario.vy = 6.0\n    end\n    mario\nend\n\nfunction update(dt, keys, mario)\n    mario = gravity(dt, mario)\n    mario = jump(keys,  mario)\n    mario = walk(keys,  mario)\n    mario = physics(dt, mario)\n    mario\nend\n\n\n\nmario2model(mario) = translationmatrix(Vec3f0(mario.x, mario.y, 0f0))*scalematrix(Vec3f0(5f0))\n\nconst mario_images = Dict()\n\n\nfunction play(x::Vector)\n    const_lift(getindex, x, loop(1:length(x)))\nend\n\nfunction read_sequence(path)\n    if isdir(path)\n        return map(load, sort(map(x- joinpath(path, x), readdir(path))))\n    else\n        return fill(load(path), 1)\n    end\nend\n\nfor verb in [ jump ,  walk ,  stand ], dir in [ left ,  right ]\n    pic = dir\n    if verb !=  walk  # not a sequemce\n        pic *=  .png \n    end\n    path = assetpath( mario , verb, pic)\n    sequence = read_sequence(path)\n    gif = map(img- map(RGBA{U8}, img), sequence)\n    mario_images[verb*dir] = play(gif)\nend\nfunction mario2image(mario, images=mario_images)\n    verb = mario.y   0.0 ?  jump  : mario.vx != 0.0 ?  walk  :  stand \n    mario_images[verb*string(mario.direction)].value # is a signal of pictures itself (animation), so .value samples the current image\nend\nfunction arrows2vec(direction)\n    direction == :up      return Vec2f0( 0.0,  1.0)\n    direction == :down    return Vec2f0( 0.0, -1.0)\n    direction == :right   return Vec2f0( 3.0,  0.0)\n    direction == :left    return Vec2f0(-3.0,  0.0)\n    Vec2f0(0.0)\nend\n\n# Put everything together\narrows          = sampleon(bounce(1:10), window.inputs[:arrow_navigation])\nkeys            = const_lift(arrows2vec, arrows)\nmario_signal    = const_lift(update, 8.0, keys, Mario(0.0, 0.0, 0.0, 0.0, :right))\nimage_stream    = const_lift(mario2image, mario_signal)\nmodelmatrix     = const_lift(mario2model, mario_signal)\n\nmario = visualize(image_stream, model=modelmatrix)\n\nview(mario, window, camera=:fixed_pixel)\n\n renderloop(window)", 
            "title": "Mario Game"
        }, 
        {
            "location": "/examples/compose/", 
            "text": "Barplot\n\n\n\n\nusing Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Gadfly, DataFrames, RDatasets\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot(dataset(\ncar\n, \nSLID\n), x=\nWages\n, color=\nLanguage\n, Geom.histogram)\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nCatgraph\n\n\n\n\nusing Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\np = plot(x=1:100, y=2.^rand(100),\n     Scale.y_sqrt, Geom.point, Geom.smooth,\n     Guide.xlabel(\nStimulus\n), Guide.ylabel(\nResponse\n), Guide.title(\nCat Training\n))\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nCompose\n\n\n\n\nusing Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Compose\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\np = compose(context(0.0mm, 0.0mm, 200mm, 200mm),\n    rectangle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1], [0.1]),\n    fill([LCHab(92, 10, 77), LCHab(68, 74, 192), LCHab(78, 84, 29)]),\n    stroke([LCHab(5, 0, 77),LCHab(5, 77, 77),LCHab(50, 0, 8)]),\n    (context(), circle(), fill(\nbisque\n)),\n    (context(), rectangle(), fill(\ntomato\n))\n)\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nErrorbar\n\n\n\n\nusing GLVisualize.ComposeBackend, Gadfly, Distributions\nusing Colors, GLVisualize\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nsds = [1, 1/2, 1/4, 1/8, 1/16, 1/32]\nn = 10\nys = [mean(rand(Distributions.Normal(0, sd), n)) for sd in sds]\nymins = ys .- (1.96 * sds / sqrt(n))\nymaxs = ys .+ (1.96 * sds / sqrt(n))\n\np = plot(x=1:length(sds), y=ys, ymin=ymins, ymax=ymaxs,\n     Geom.point, Geom.errorbar)\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nRegression\n\n\n\n\nusing GLVisualize.ComposeBackend, Gadfly\nusing Colors, GLVisualize\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\nusing Distributions\nx1 = rand(40)\ny1 = 4.*x1 .+ 2 .+randn(40)\nx2 = rand(40)\ny2 = -6.*x2 .+ 3 .+ randn(40)\nx  = [x1;x2]\ny  = [y1;y2]\ncol = [fill(\nSlope 4\n,40); fill(\nSlope -6\n,40)]\np = plot(x=x,y=y,colour=col, Geom.point, Geom.smooth(method=:lm))\n\ndraw(composebackend, p)\n\nrenderloop(window)\n\n\n\n\n\nSingraph\n\n\n\n\nusing Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot([sin, cos], 0, 25)\n\ndraw(composebackend, p)\nrenderloop(window)\n\n\n\n\n\nSin Dataframe\n\n\n\n\nusing Colors, GLVisualize\nusing DataFrames, Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nxs = 0:0.1:20\n\ndf_cos = DataFrame(\n    x=xs,\n    y=cos(xs),\n    ymin=cos(xs) .- 0.5,\n    ymax=cos(xs) .+ 0.5,\n    f=\ncos\n\n)\ndf_sin = DataFrame(\n    x=xs,\n    y=sin(xs),\n    ymin=sin(xs) .- 0.5,\n    ymax=sin(xs) .+ 0.5,\n    f=\nsin\n\n)\ndf = vcat(df_cos, df_sin)\np = plot(df, x=:x, y=:y, ymin=:ymin, ymax=:ymax, color=:f, Geom.line, Geom.ribbon)\n\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Compose"
        }, 
        {
            "location": "/examples/compose/#barplot", 
            "text": "using Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Gadfly, DataFrames, RDatasets\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot(dataset( car ,  SLID ), x= Wages , color= Language , Geom.histogram)\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Barplot"
        }, 
        {
            "location": "/examples/compose/#catgraph", 
            "text": "using Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\np = plot(x=1:100, y=2.^rand(100),\n     Scale.y_sqrt, Geom.point, Geom.smooth,\n     Guide.xlabel( Stimulus ), Guide.ylabel( Response ), Guide.title( Cat Training ))\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Catgraph"
        }, 
        {
            "location": "/examples/compose/#compose", 
            "text": "using Colors, GLVisualize\nusing GLVisualize.ComposeBackend, Compose\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\np = compose(context(0.0mm, 0.0mm, 200mm, 200mm),\n    rectangle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1], [0.1]),\n    fill([LCHab(92, 10, 77), LCHab(68, 74, 192), LCHab(78, 84, 29)]),\n    stroke([LCHab(5, 0, 77),LCHab(5, 77, 77),LCHab(50, 0, 8)]),\n    (context(), circle(), fill( bisque )),\n    (context(), rectangle(), fill( tomato ))\n)\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Compose"
        }, 
        {
            "location": "/examples/compose/#errorbar", 
            "text": "using GLVisualize.ComposeBackend, Gadfly, Distributions\nusing Colors, GLVisualize\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nsds = [1, 1/2, 1/4, 1/8, 1/16, 1/32]\nn = 10\nys = [mean(rand(Distributions.Normal(0, sd), n)) for sd in sds]\nymins = ys .- (1.96 * sds / sqrt(n))\nymaxs = ys .+ (1.96 * sds / sqrt(n))\n\np = plot(x=1:length(sds), y=ys, ymin=ymins, ymax=ymaxs,\n     Geom.point, Geom.errorbar)\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Errorbar"
        }, 
        {
            "location": "/examples/compose/#regression", 
            "text": "using GLVisualize.ComposeBackend, Gadfly\nusing Colors, GLVisualize\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\n\nusing Distributions\nx1 = rand(40)\ny1 = 4.*x1 .+ 2 .+randn(40)\nx2 = rand(40)\ny2 = -6.*x2 .+ 3 .+ randn(40)\nx  = [x1;x2]\ny  = [y1;y2]\ncol = [fill( Slope 4 ,40); fill( Slope -6 ,40)]\np = plot(x=x,y=y,colour=col, Geom.point, Geom.smooth(method=:lm))\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Regression"
        }, 
        {
            "location": "/examples/compose/#singraph", 
            "text": "using Colors, GLVisualize\nusing Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\np = plot([sin, cos], 0, 25)\n\ndraw(composebackend, p)\nrenderloop(window)", 
            "title": "Singraph"
        }, 
        {
            "location": "/examples/compose/#sin-dataframe", 
            "text": "using Colors, GLVisualize\nusing DataFrames, Gadfly, GLVisualize.ComposeBackend\n\n window = glscreen()\n composebackend = ComposeBackend.GLVisualizeBackend(window)\n\n\nxs = 0:0.1:20\n\ndf_cos = DataFrame(\n    x=xs,\n    y=cos(xs),\n    ymin=cos(xs) .- 0.5,\n    ymax=cos(xs) .+ 0.5,\n    f= cos \n)\ndf_sin = DataFrame(\n    x=xs,\n    y=sin(xs),\n    ymin=sin(xs) .- 0.5,\n    ymax=sin(xs) .+ 0.5,\n    f= sin \n)\ndf = vcat(df_cos, df_sin)\np = plot(df, x=:x, y=:y, ymin=:ymin, ymax=:ymax, color=:f, Geom.line, Geom.ribbon)\n\n\ndraw(composebackend, p)\n\nrenderloop(window)", 
            "title": "Sin Dataframe"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/performance/", 
            "text": "", 
            "title": "Performance"
        }
    ]
}